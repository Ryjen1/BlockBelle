{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/@wagmi/core/dist/esm/query/readContract.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/%40wagmi/core/src/query/readContract.ts"],"sourcesContent":["import type { QueryOptions } from '@tanstack/query-core'\nimport type { Abi, ContractFunctionArgs, ContractFunctionName } from 'viem'\n\nimport {\n  type ReadContractErrorType,\n  type ReadContractParameters,\n  type ReadContractReturnType,\n  readContract,\n} from '../actions/readContract.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { UnionExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type ReadContractOptions<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  config extends Config,\n> = UnionExactPartial<ReadContractParameters<abi, functionName, args, config>> &\n  ScopeKeyParameter\n\nexport function readContractQueryOptions<\n  config extends Config,\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n>(\n  config: config,\n  options: ReadContractOptions<abi, functionName, args, config> = {} as any,\n) {\n  return {\n    // TODO: Support `signal` once Viem actions allow passthrough\n    // https://tkdodo.eu/blog/why-you-want-react-query#bonus-cancellation\n    async queryFn({ queryKey }) {\n      const abi = options.abi as Abi\n      if (!abi) throw new Error('abi is required')\n\n      const { functionName, scopeKey: _, ...parameters } = queryKey[1]\n      const addressOrCodeParams = (() => {\n        const params = queryKey[1] as unknown as ReadContractParameters\n        if (params.address) return { address: params.address }\n        if (params.code) return { code: params.code }\n        throw new Error('address or code is required')\n      })()\n\n      if (!functionName) throw new Error('functionName is required')\n\n      return readContract(config, {\n        abi,\n        functionName,\n        args: parameters.args as readonly unknown[],\n        ...addressOrCodeParams,\n        ...parameters,\n      }) as Promise<ReadContractData<abi, functionName, args>>\n    },\n    queryKey: readContractQueryKey(options as any) as any,\n  } as const satisfies QueryOptions<\n    ReadContractQueryFnData<abi, functionName, args>,\n    ReadContractErrorType,\n    ReadContractData<abi, functionName, args>,\n    ReadContractQueryKey<abi, functionName, args, config>\n  >\n}\n\nexport type ReadContractQueryFnData<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n> = ReadContractReturnType<abi, functionName, args>\n\nexport type ReadContractData<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n> = ReadContractQueryFnData<abi, functionName, args>\n\nexport function readContractQueryKey<\n  config extends Config,\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n>(options: ReadContractOptions<abi, functionName, args, config> = {} as any) {\n  const { abi: _, ...rest } = options\n  return ['readContract', filterQueryOptions(rest)] as const\n}\n\nexport type ReadContractQueryKey<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  config extends Config,\n> = ReturnType<typeof readContractQueryKey<config, abi, functionName, args>>\n"],"names":[],"mappings":";;;;;;AAGA,OAAO,EAIL,YAAY,GACb,MAAM,4BAA4B,CAAA;AAInC,OAAO,EAAE,kBAAkB,EAAE,MAAM,YAAY,CAAA;;;AAUzC,SAAU,wBAAwB,CAMtC,MAAc,EACd,UAAgE,CAAA,CAAS;IAEzE,OAAO;QACL,6DAA6D;QAC7D,qEAAqE;QACrE,KAAK,CAAC,OAAO,EAAC,EAAE,QAAQ,EAAE;YACxB,MAAM,GAAG,GAAG,OAAO,CAAC,GAAU,CAAA;YAC9B,IAAI,CAAC,GAAG,EAAE,MAAM,IAAI,KAAK,CAAC,iBAAiB,CAAC,CAAA;YAE5C,MAAM,EAAE,YAAY,EAAE,QAAQ,EAAE,CAAC,EAAE,GAAG,UAAU,EAAE,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAA;YAChE,MAAM,mBAAmB,GAAG,CAAC,GAAG,EAAE;gBAChC,MAAM,MAAM,GAAG,QAAQ,CAAC,CAAC,CAAsC,CAAA;gBAC/D,IAAI,MAAM,CAAC,OAAO,EAAE,OAAO;oBAAE,OAAO,EAAE,MAAM,CAAC,OAAO;gBAAA,CAAE,CAAA;gBACtD,IAAI,MAAM,CAAC,IAAI,EAAE,OAAO;oBAAE,IAAI,EAAE,MAAM,CAAC,IAAI;gBAAA,CAAE,CAAA;gBAC7C,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC,CAAA;YAChD,CAAC,CAAC,EAAE,CAAA;YAEJ,IAAI,CAAC,YAAY,EAAE,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAA;YAE9D,WAAO,mPAAY,EAAC,MAAM,EAAE;gBAC1B,GAAG;gBACH,YAAY;gBACZ,IAAI,EAAE,UAAU,CAAC,IAA0B;gBAC3C,GAAG,mBAAmB;gBACtB,GAAG,UAAU;aACd,CAAuD,CAAA;QAC1D,CAAC;QACD,QAAQ,EAAE,oBAAoB,CAAC,OAAc,CAAQ;KAMtD,CAAA;AACH,CAAC;AAcK,SAAU,oBAAoB,CAKlC,UAAgE,CAAA,CAAS;IACzE,MAAM,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,IAAI,EAAE,GAAG,OAAO,CAAA;IACnC,OAAO;QAAC,cAAc;YAAE,gPAAkB,EAAC,IAAI,CAAC;KAAU,CAAA;AAC5D,CAAC"}},
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/wagmi/dist/esm/hooks/useReadContract.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/wagmi/src/hooks/useReadContract.ts"],"sourcesContent":["'use client'\n\nimport type {\n  Config,\n  ReadContractErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport type { UnionCompute } from '@wagmi/core/internal'\nimport {\n  type ReadContractData,\n  type ReadContractOptions,\n  type ReadContractQueryFnData,\n  type ReadContractQueryKey,\n  readContractQueryOptions,\n  structuralSharing,\n} from '@wagmi/core/query'\nimport type { Abi, ContractFunctionArgs, ContractFunctionName, Hex } from 'viem'\n\nimport type { ConfigParameter, QueryParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseReadContractParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'pure' | 'view'\n  > = ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'pure' | 'view',\n    functionName\n  > = ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  config extends Config = Config,\n  selectData = ReadContractData<abi, functionName, args>,\n> = UnionCompute<\n  ReadContractOptions<abi, functionName, args, config> &\n    ConfigParameter<config> &\n    QueryParameter<\n      ReadContractQueryFnData<abi, functionName, args>,\n      ReadContractErrorType,\n      selectData,\n      ReadContractQueryKey<abi, functionName, args, config>\n    >\n>\n\nexport type UseReadContractReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'pure' | 'view'\n  > = ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'pure' | 'view',\n    functionName\n  > = ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  selectData = ReadContractData<abi, functionName, args>,\n> = UseQueryReturnType<selectData, ReadContractErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useReadContract */\nexport function useReadContract<\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  config extends Config = ResolvedRegister['config'],\n  selectData = ReadContractData<abi, functionName, args>,\n>(\n  parameters: UseReadContractParameters<\n    abi,\n    functionName,\n    args,\n    config,\n    selectData\n  > = {} as any,\n): UseReadContractReturnType<abi, functionName, args, selectData> {\n  const { abi, address, functionName, query = {} } = parameters\n  // @ts-ignore\n  const code = parameters.code as Hex | undefined\n\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n\n  const options = readContractQueryOptions<config, abi, functionName, args>(\n    config,\n    { ...(parameters as any), chainId: parameters.chainId ?? chainId },\n  )\n  const enabled = Boolean(\n    (address || code) && abi && functionName && (query.enabled ?? true),\n  )\n\n  return useQuery({\n    ...query,\n    ...options,\n    enabled,\n    structuralSharing: query.structuralSharing ?? structuralSharing,\n  })\n}\n"],"names":[],"mappings":";;;;AAQA,OAAO,EAKL,wBAAwB,EACxB,iBAAiB,GAClB,MAAM,mBAAmB,CAAA;;AAI1B,OAAO,EAA2B,QAAQ,EAAE,MAAM,mBAAmB,CAAA;AACrE,OAAO,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAA;AAC5C,OAAO,EAAE,SAAS,EAAE,MAAM,gBAAgB,CAAA;AArB1C,YAAY,CAAA;;;;;AA8DN,SAAU,eAAe,CAO7B,aAMI,CAAA,CAAS;IAEb,MAAM,EAAE,GAAG,EAAE,OAAO,EAAE,YAAY,EAAE,KAAK,GAAG,CAAA,CAAE,EAAE,GAAG,UAAU,CAAA;IAC7D,aAAa;IACb,MAAM,IAAI,GAAG,UAAU,CAAC,IAAuB,CAAA;IAE/C,MAAM,MAAM,OAAG,iOAAS,EAAC,UAAU,CAAC,CAAA;IACpC,MAAM,OAAO,OAAG,mOAAU,EAAC;QAAE,MAAM;IAAA,CAAE,CAAC,CAAA;IAEtC,MAAM,OAAO,OAAG,6PAAwB,EACtC,MAAM,EACN;QAAE,GAAI,UAAkB;QAAE,OAAO,EAAE,UAAU,CAAC,OAAO,IAAI,OAAO;IAAA,CAAE,CACnE,CAAA;IACD,MAAM,OAAO,GAAG,OAAO,CACrB,CAAC,OAAO,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,YAAY,IAAI,CAAC,KAAK,CAAC,OAAO,IAAI,IAAI,CAAC,CACpE,CAAA;IAED,WAAO,4OAAQ,EAAC;QACd,GAAG,KAAK;QACR,GAAG,OAAO;QACV,OAAO;QACP,iBAAiB,EAAE,KAAK,CAAC,iBAAiB,IAAI,+OAAiB;KAChE,CAAC,CAAA;AACJ,CAAC"}},
    {"offset": {"line": 93, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/_esm/utils/chain/assertCurrentChain.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/utils/chain/assertCurrentChain.ts"],"sourcesContent":["import {\n  ChainMismatchError,\n  type ChainMismatchErrorType,\n  ChainNotFoundError,\n  type ChainNotFoundErrorType,\n} from '../../errors/chain.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\n\nexport type AssertCurrentChainParameters = {\n  chain?: Chain | undefined\n  currentChainId: number\n}\n\nexport type AssertCurrentChainErrorType =\n  | ChainNotFoundErrorType\n  | ChainMismatchErrorType\n  | ErrorType\n\nexport function assertCurrentChain({\n  chain,\n  currentChainId,\n}: AssertCurrentChainParameters): void {\n  if (!chain) throw new ChainNotFoundError()\n  if (currentChainId !== chain.id)\n    throw new ChainMismatchError({ chain, currentChainId })\n}\n"],"names":[],"mappings":";;;;AAAA,OAAO,EACL,kBAAkB,EAElB,kBAAkB,GAEnB,MAAM,uBAAuB,CAAA;;AAcxB,SAAU,kBAAkB,CAAC,EACjC,KAAK,EACL,cAAc,EACe;IAC7B,IAAI,CAAC,KAAK,EAAE,MAAM,IAAI,+NAAkB,EAAE,CAAA;IAC1C,IAAI,cAAc,KAAK,KAAK,CAAC,EAAE,EAC7B,MAAM,IAAI,+NAAkB,CAAC;QAAE,KAAK;QAAE,cAAc;IAAA,CAAE,CAAC,CAAA;AAC3D,CAAC"}},
    {"offset": {"line": 110, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/_esm/utils/errors/getTransactionError.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/utils/errors/getTransactionError.ts"],"sourcesContent":["import type { Account } from '../../accounts/types.js'\nimport type { SendTransactionParameters } from '../../actions/wallet/sendTransaction.js'\nimport type { BaseError } from '../../errors/base.js'\nimport { UnknownNodeError } from '../../errors/node.js'\nimport {\n  TransactionExecutionError,\n  type TransactionExecutionErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\n\nimport {\n  type GetNodeErrorParameters,\n  type GetNodeErrorReturnType,\n  getNodeError,\n} from './getNodeError.js'\n\nexport type GetTransactionErrorParameters = Omit<\n  SendTransactionParameters,\n  'account' | 'chain'\n> & {\n  account: Account | null\n  chain?: Chain | undefined\n  docsPath?: string | undefined\n}\n\nexport type GetTransactionErrorReturnType<cause = ErrorType> = Omit<\n  TransactionExecutionErrorType,\n  'cause'\n> & { cause: cause | GetNodeErrorReturnType }\n\nexport function getTransactionError<err extends ErrorType<string>>(\n  err: err,\n  { docsPath, ...args }: GetTransactionErrorParameters,\n): GetTransactionErrorReturnType<err> {\n  const cause = (() => {\n    const cause = getNodeError(\n      err as {} as BaseError,\n      args as GetNodeErrorParameters,\n    )\n    if (cause instanceof UnknownNodeError) return err as {} as BaseError\n    return cause\n  })()\n  return new TransactionExecutionError(cause, {\n    docsPath,\n    ...args,\n  }) as GetTransactionErrorReturnType<err>\n}\n"],"names":[],"mappings":";;;;AAGA,OAAO,EAAE,gBAAgB,EAAE,MAAM,sBAAsB,CAAA;AACvD,OAAO,EACL,yBAAyB,GAE1B,MAAM,6BAA6B,CAAA;AAIpC,OAAO,EAGL,YAAY,GACb,MAAM,mBAAmB,CAAA;;;;AAgBpB,SAAU,mBAAmB,CACjC,GAAQ,EACR,EAAE,QAAQ,EAAE,GAAG,IAAI,EAAiC;IAEpD,MAAM,KAAK,GAAG,CAAC,GAAG,EAAE;QAClB,MAAM,KAAK,OAAG,yOAAY,EACxB,GAAsB,EACtB,IAA8B,CAC/B,CAAA;QACD,IAAI,KAAK,YAAY,4NAAgB,EAAE,OAAO,GAAsB,CAAA;QACpE,OAAO,KAAK,CAAA;IACd,CAAC,CAAC,EAAE,CAAA;IACJ,OAAO,IAAI,4OAAyB,CAAC,KAAK,EAAE;QAC1C,QAAQ;QACR,GAAG,IAAI;KACR,CAAuC,CAAA;AAC1C,CAAC"}},
    {"offset": {"line": 135, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/_esm/actions/wallet/sendTransaction.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/actions/wallet/sendTransaction.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { SignTransactionErrorType } from '../../accounts/utils/signTransaction.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  AccountNotFoundError,\n  type AccountNotFoundErrorType,\n  AccountTypeNotSupportedError,\n  type AccountTypeNotSupportedErrorType,\n} from '../../errors/account.js'\nimport { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../types/chain.js'\nimport type { GetTransactionRequestKzgParameter } from '../../types/kzg.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport type { UnionOmit } from '../../types/utils.js'\nimport {\n  type RecoverAuthorizationAddressErrorType,\n  recoverAuthorizationAddress,\n} from '../../utils/authorization/recoverAuthorizationAddress.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type AssertCurrentChainErrorType,\n  assertCurrentChain,\n} from '../../utils/chain/assertCurrentChain.js'\nimport {\n  type GetTransactionErrorReturnType,\n  getTransactionError,\n} from '../../utils/errors/getTransactionError.js'\nimport { extract } from '../../utils/formatters/extract.js'\nimport {\n  type FormattedTransactionRequest,\n  formatTransactionRequest,\n} from '../../utils/formatters/transactionRequest.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { LruMap } from '../../utils/lru.js'\nimport {\n  type AssertRequestErrorType,\n  type AssertRequestParameters,\n  assertRequest,\n} from '../../utils/transaction/assertRequest.js'\nimport { type GetChainIdErrorType, getChainId } from '../public/getChainId.js'\nimport {\n  defaultParameters,\n  type PrepareTransactionRequestErrorType,\n  prepareTransactionRequest,\n} from './prepareTransactionRequest.js'\nimport {\n  type SendRawTransactionErrorType,\n  sendRawTransaction,\n} from './sendRawTransaction.js'\n\nconst supportsWalletNamespace = new LruMap<boolean>(128)\n\nexport type SendTransactionRequest<\n  chain extends Chain | undefined = Chain | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  ///\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = UnionOmit<FormattedTransactionRequest<_derivedChain>, 'from'> &\n  GetTransactionRequestKzgParameter\n\nexport type SendTransactionParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  request extends SendTransactionRequest<\n    chain,\n    chainOverride\n  > = SendTransactionRequest<chain, chainOverride>,\n> = request &\n  GetAccountParameter<account, Account | Address, true, true> &\n  GetChainParameter<chain, chainOverride> &\n  GetTransactionRequestKzgParameter<request>\n\nexport type SendTransactionReturnType = Hash\n\nexport type SendTransactionErrorType =\n  | ParseAccountErrorType\n  | GetTransactionErrorReturnType<\n      | AccountNotFoundErrorType\n      | AccountTypeNotSupportedErrorType\n      | AssertCurrentChainErrorType\n      | AssertRequestErrorType\n      | GetChainIdErrorType\n      | PrepareTransactionRequestErrorType\n      | SendRawTransactionErrorType\n      | RecoverAuthorizationAddressErrorType\n      | SignTransactionErrorType\n      | RequestErrorType\n    >\n  | ErrorType\n\n/**\n * Creates, signs, and sends a new transaction to the network.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/sendTransaction\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_sending-transactions\n * - JSON-RPC Methods:\n *   - JSON-RPC Accounts: [`eth_sendTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction)\n *   - Local Accounts: [`eth_sendRawTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendrawtransaction)\n *\n * @param client - Client to use\n * @param parameters - {@link SendTransactionParameters}\n * @returns The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link SendTransactionReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { sendTransaction } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const hash = await sendTransaction(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { sendTransaction } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const hash = await sendTransaction(client, {\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n */\nexport async function sendTransaction<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  const request extends SendTransactionRequest<chain, chainOverride>,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: SendTransactionParameters<chain, account, chainOverride, request>,\n): Promise<SendTransactionReturnType> {\n  const {\n    account: account_ = client.account,\n    chain = client.chain,\n    accessList,\n    authorizationList,\n    blobs,\n    data,\n    gas,\n    gasPrice,\n    maxFeePerBlobGas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    type,\n    value,\n    ...rest\n  } = parameters\n\n  if (typeof account_ === 'undefined')\n    throw new AccountNotFoundError({\n      docsPath: '/docs/actions/wallet/sendTransaction',\n    })\n  const account = account_ ? parseAccount(account_) : null\n\n  try {\n    assertRequest(parameters as AssertRequestParameters)\n\n    const to = await (async () => {\n      // If `to` exists on the parameters, use that.\n      if (parameters.to) return parameters.to\n\n      // If `to` is null, we are sending a deployment transaction.\n      if (parameters.to === null) return undefined\n\n      // If no `to` exists, and we are sending a EIP-7702 transaction, use the\n      // address of the first authorization in the list.\n      if (authorizationList && authorizationList.length > 0)\n        return await recoverAuthorizationAddress({\n          authorization: authorizationList[0],\n        }).catch(() => {\n          throw new BaseError(\n            '`to` is required. Could not infer from `authorizationList`.',\n          )\n        })\n\n      // Otherwise, we are sending a deployment transaction.\n      return undefined\n    })()\n\n    if (account?.type === 'json-rpc' || account === null) {\n      let chainId: number | undefined\n      if (chain !== null) {\n        chainId = await getAction(client, getChainId, 'getChainId')({})\n        assertCurrentChain({\n          currentChainId: chainId,\n          chain,\n        })\n      }\n\n      const chainFormat = client.chain?.formatters?.transactionRequest?.format\n      const format = chainFormat || formatTransactionRequest\n\n      const request = format(\n        {\n          // Pick out extra data that might exist on the chain's transaction request type.\n          ...extract(rest, { format: chainFormat }),\n          accessList,\n          account,\n          authorizationList,\n          blobs,\n          chainId,\n          data,\n          gas,\n          gasPrice,\n          maxFeePerBlobGas,\n          maxFeePerGas,\n          maxPriorityFeePerGas,\n          nonce,\n          to,\n          type,\n          value,\n        } as TransactionRequest,\n        'sendTransaction',\n      )\n\n      const isWalletNamespaceSupported = supportsWalletNamespace.get(client.uid)\n      const method = isWalletNamespaceSupported\n        ? 'wallet_sendTransaction'\n        : 'eth_sendTransaction'\n\n      try {\n        return await client.request(\n          {\n            method,\n            params: [request],\n          },\n          { retryCount: 0 },\n        )\n      } catch (e) {\n        if (isWalletNamespaceSupported === false) throw e\n\n        const error = e as BaseError\n        // If the transport does not support the method or input, attempt to use the\n        // `wallet_sendTransaction` method.\n        if (\n          error.name === 'InvalidInputRpcError' ||\n          error.name === 'InvalidParamsRpcError' ||\n          error.name === 'MethodNotFoundRpcError' ||\n          error.name === 'MethodNotSupportedRpcError'\n        ) {\n          return await client\n            .request(\n              {\n                method: 'wallet_sendTransaction',\n                params: [request],\n              },\n              { retryCount: 0 },\n            )\n            .then((hash) => {\n              supportsWalletNamespace.set(client.uid, true)\n              return hash\n            })\n            .catch((e) => {\n              const walletNamespaceError = e as BaseError\n              if (\n                walletNamespaceError.name === 'MethodNotFoundRpcError' ||\n                walletNamespaceError.name === 'MethodNotSupportedRpcError'\n              ) {\n                supportsWalletNamespace.set(client.uid, false)\n                throw error\n              }\n\n              throw walletNamespaceError\n            })\n        }\n\n        throw error\n      }\n    }\n\n    if (account?.type === 'local') {\n      // Prepare the request for signing (assign appropriate fees, etc.)\n      const request = await getAction(\n        client,\n        prepareTransactionRequest,\n        'prepareTransactionRequest',\n      )({\n        account,\n        accessList,\n        authorizationList,\n        blobs,\n        chain,\n        data,\n        gas,\n        gasPrice,\n        maxFeePerBlobGas,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        nonce,\n        nonceManager: account.nonceManager,\n        parameters: [...defaultParameters, 'sidecars'],\n        type,\n        value,\n        ...rest,\n        to,\n      } as any)\n\n      const serializer = chain?.serializers?.transaction\n      const serializedTransaction = (await account.signTransaction(request, {\n        serializer,\n      })) as Hash\n      return await getAction(\n        client,\n        sendRawTransaction,\n        'sendRawTransaction',\n      )({\n        serializedTransaction,\n      })\n    }\n\n    if (account?.type === 'smart')\n      throw new AccountTypeNotSupportedError({\n        metaMessages: [\n          'Consider using the `sendUserOperation` Action instead.',\n        ],\n        docsPath: '/docs/actions/bundler/sendUserOperation',\n        type: 'smart',\n      })\n\n    throw new AccountTypeNotSupportedError({\n      docsPath: '/docs/actions/wallet/sendTransaction',\n      type: (account as any)?.type,\n    })\n  } catch (err) {\n    if (err instanceof AccountTypeNotSupportedError) throw err\n    throw getTransactionError(err as BaseError, {\n      ...parameters,\n      account,\n      chain: parameters.chain || undefined,\n    })\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 319, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/_esm/actions/wallet/writeContract.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/actions/wallet/writeContract.ts"],"sourcesContent":["import type { Abi, Address } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  AccountNotFoundError,\n  type AccountNotFoundErrorType,\n} from '../../errors/account.js'\nimport type { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../types/chain.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n  ContractFunctionParameters,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { Prettify, UnionEvaluate, UnionOmit } from '../../types/utils.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  type EncodeFunctionDataParameters,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetContractErrorReturnType,\n  getContractError,\n} from '../../utils/errors/getContractError.js'\nimport type { FormattedTransactionRequest } from '../../utils/formatters/transactionRequest.js'\nimport { getAction } from '../../utils/getAction.js'\nimport type { GetMutabilityAwareValue } from '../public/simulateContract.js'\nimport {\n  type SendTransactionErrorType,\n  type SendTransactionReturnType,\n  sendTransaction,\n} from './sendTransaction.js'\nimport type { sendTransactionSync } from './sendTransactionSync.js'\n\nexport type WriteContractParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'nonpayable' | 'payable'\n  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  ///\n  allFunctionNames = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = ContractFunctionParameters<\n  abi,\n  'nonpayable' | 'payable',\n  functionName,\n  args,\n  false,\n  allFunctionNames\n> &\n  GetChainParameter<chain, chainOverride> &\n  Prettify<\n    GetAccountParameter<account, Account | Address, true, true> &\n      GetMutabilityAwareValue<\n        abi,\n        'nonpayable' | 'payable',\n        functionName,\n        FormattedTransactionRequest<derivedChain>['value'],\n        args\n      > & {\n        /** Data to append to the end of the calldata. Useful for adding a [\"domain\" tag](https://opensea.notion.site/opensea/Seaport-Order-Attributions-ec2d69bf455041a5baa490941aad307f). */\n        dataSuffix?: Hex | undefined\n      }\n  > &\n  UnionEvaluate<\n    UnionOmit<\n      FormattedTransactionRequest<derivedChain>,\n      'data' | 'from' | 'to' | 'value'\n    >\n  >\n\nexport type WriteContractReturnType = SendTransactionReturnType\n\nexport type WriteContractErrorType =\n  | EncodeFunctionDataErrorType\n  | AccountNotFoundErrorType\n  | ParseAccountErrorType\n  | GetContractErrorReturnType<SendTransactionErrorType>\n  | ErrorType\n\n/**\n * Executes a write function on a contract.\n *\n * - Docs: https://viem.sh/docs/contract/writeContract\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_writing-to-contracts\n *\n * A \"write\" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, and hence a [Transaction](https://viem.sh/docs/glossary/terms) is needed to be broadcast in order to change the state.\n *\n * Internally, uses a [Wallet Client](https://viem.sh/docs/clients/wallet) to call the [`sendTransaction` action](https://viem.sh/docs/actions/wallet/sendTransaction) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n *\n * __Warning: The `write` internally sends a transaction – it does not validate if the contract write will succeed (the contract may throw an error). It is highly recommended to [simulate the contract write with `contract.simulate`](https://viem.sh/docs/contract/writeContract#usage) before you execute it.__\n *\n * @param client - Client to use\n * @param parameters - {@link WriteContractParameters}\n * @returns A [Transaction Hash](https://viem.sh/docs/glossary/terms#hash). {@link WriteContractReturnType}\n *\n * @example\n * import { createWalletClient, custom, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { writeContract } from 'viem/contract'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const hash = await writeContract(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n *   functionName: 'mint',\n *   args: [69420],\n * })\n *\n * @example\n * // With Validation\n * import { createWalletClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { simulateContract, writeContract } from 'viem/contract'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const { request } = await simulateContract(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n *   functionName: 'mint',\n *   args: [69420],\n * }\n * const hash = await writeContract(client, request)\n */\nexport async function writeContract<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  chainOverride extends Chain | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: WriteContractParameters<\n    abi,\n    functionName,\n    args,\n    chain,\n    account,\n    chainOverride\n  >,\n): Promise<WriteContractReturnType> {\n  return writeContract.internal(\n    client,\n    sendTransaction,\n    'sendTransaction',\n    parameters,\n  ) as never\n}\n\nexport namespace writeContract {\n  export async function internal<\n    chain extends Chain | undefined,\n    account extends Account | undefined,\n    const abi extends Abi | readonly unknown[],\n    functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n    args extends ContractFunctionArgs<\n      abi,\n      'nonpayable' | 'payable',\n      functionName\n    >,\n    chainOverride extends Chain | undefined,\n  >(\n    client: Client<Transport, chain, account>,\n    actionFn: typeof sendTransaction | typeof sendTransactionSync,\n    name: 'sendTransaction' | 'sendTransactionSync',\n    parameters: WriteContractParameters<\n      abi,\n      functionName,\n      args,\n      chain,\n      account,\n      chainOverride\n    >,\n  ) {\n    const {\n      abi,\n      account: account_ = client.account,\n      address,\n      args,\n      dataSuffix,\n      functionName,\n      ...request\n    } = parameters as WriteContractParameters\n\n    if (typeof account_ === 'undefined')\n      throw new AccountNotFoundError({\n        docsPath: '/docs/contract/writeContract',\n      })\n    const account = account_ ? parseAccount(account_) : null\n\n    const data = encodeFunctionData({\n      abi,\n      args,\n      functionName,\n    } as EncodeFunctionDataParameters)\n\n    try {\n      return await getAction(\n        client,\n        actionFn as never,\n        name,\n      )({\n        data: `${data}${dataSuffix ? dataSuffix.replace('0x', '') : ''}`,\n        to: address,\n        account,\n        ...request,\n      })\n    } catch (error) {\n      throw getContractError(error as BaseError, {\n        abi,\n        address,\n        args,\n        docsPath: '/docs/contract/writeContract',\n        functionName,\n        sender: account?.address,\n      })\n    }\n  }\n}\n"],"names":[],"mappings":";;;;AAGA,OAAO,EAEL,YAAY,GACb,MAAM,sCAAsC,CAAA;AAG7C,OAAO,EACL,oBAAoB,GAErB,MAAM,yBAAyB,CAAA;AAgBhC,OAAO,EAGL,kBAAkB,GACnB,MAAM,uCAAuC,CAAA;AAC9C,OAAO,EAEL,gBAAgB,GACjB,MAAM,wCAAwC,CAAA;AAE/C,OAAO,EAAE,SAAS,EAAE,MAAM,0BAA0B,CAAA;AAEpD,OAAO,EAGL,eAAe,GAChB,MAAM,sBAAsB,CAAA;;;;;;;AA4GtB,KAAK,UAAU,aAAa,CAYjC,MAAyC,EACzC,UAOC;IAED,OAAO,aAAa,CAAC,QAAQ,CAC3B,MAAM,EACN,iPAAe,EACf,iBAAiB,EACjB,UAAU,CACF,CAAA;AACZ,CAAC;AAED,CAAA,SAAiB,aAAa;IACrB,KAAK,UAAU,QAAQ,CAY5B,MAAyC,EACzC,QAA6D,EAC7D,IAA+C,EAC/C,UAOC;QAED,MAAM,EACJ,GAAG,EACH,OAAO,EAAE,QAAQ,GAAG,MAAM,CAAC,OAAO,EAClC,OAAO,EACP,IAAI,EACJ,UAAU,EACV,YAAY,EACZ,GAAG,OAAO,EACX,GAAG,UAAqC,CAAA;QAEzC,IAAI,OAAO,QAAQ,KAAK,WAAW,EACjC,MAAM,IAAI,mOAAoB,CAAC;YAC7B,QAAQ,EAAE,8BAA8B;SACzC,CAAC,CAAA;QACJ,MAAM,OAAO,GAAG,QAAQ,CAAC,CAAC,KAAC,2OAAY,EAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,IAAI,CAAA;QAExD,MAAM,IAAI,OAAG,kPAAkB,EAAC;YAC9B,GAAG;YACH,IAAI;YACJ,YAAY;SACmB,CAAC,CAAA;QAElC,IAAI,CAAC;YACH,OAAO,UAAM,yNAAS,EACpB,MAAM,EACN,QAAiB,EACjB,IAAI,CACL,CAAC;gBACA,IAAI,EAAE,GAAG,IAAI,GAAG,UAAU,CAAC,CAAC,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE;gBAChE,EAAE,EAAE,OAAO;gBACX,OAAO;gBACP,GAAG,OAAO;aACX,CAAC,CAAA;QACJ,CAAC,CAAC,OAAO,KAAK,EAAE,CAAC;YACf,UAAM,iPAAgB,EAAC,KAAkB,EAAE;gBACzC,GAAG;gBACH,OAAO;gBACP,IAAI;gBACJ,QAAQ,EAAE,8BAA8B;gBACxC,YAAY;gBACZ,MAAM,EAAE,OAAO,EAAE,OAAO;aACzB,CAAC,CAAA;QACJ,CAAC;IACH,CAAC;IAnEqB,cAAA,QAAQ,GAAA,QAmE7B,CAAA;AACH,CAAC,EArEgB,aAAa,IAAA,CAAb,aAAa,GAAA,CAAA,CAAA,GAqE7B"}},
    {"offset": {"line": 374, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/@wagmi/core/dist/esm/actions/writeContract.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/%40wagmi/core/src/actions/writeContract.ts"],"sourcesContent":["import type {\n  Abi,\n  Account,\n  Chain,\n  Client,\n  ContractFunctionArgs,\n  ContractFunctionName,\n} from 'viem'\nimport {\n  type WriteContractErrorType as viem_WriteContractErrorType,\n  type WriteContractParameters as viem_WriteContractParameters,\n  type WriteContractReturnType as viem_WriteContractReturnType,\n  writeContract as viem_writeContract,\n} from 'viem/actions'\n\nimport type { Config } from '../createConfig.js'\nimport type { BaseErrorType, ErrorType } from '../errors/base.js'\nimport type { SelectChains } from '../types/chain.js'\nimport type {\n  ChainIdParameter,\n  ConnectorParameter,\n} from '../types/properties.js'\nimport type { Compute, UnionCompute } from '../types/utils.js'\nimport { getAction } from '../utils/getAction.js'\nimport {\n  type GetConnectorClientErrorType,\n  getConnectorClient,\n} from './getConnectorClient.js'\n\nexport type WriteContractParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'nonpayable' | 'payable'\n  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  ///\n  allFunctionNames = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  chains extends readonly Chain[] = SelectChains<config, chainId>,\n> = UnionCompute<\n  {\n    // TODO: Should use `UnionStrictOmit<..., 'chain'>` on `viem_WriteContractParameters` result instead\n    // temp workaround that doesn't affect runtime behavior for https://github.com/wevm/wagmi/issues/3981\n    [key in keyof chains]: viem_WriteContractParameters<\n      abi,\n      functionName,\n      args,\n      chains[key],\n      Account,\n      chains[key],\n      allFunctionNames\n    >\n  }[number] &\n    Compute<ChainIdParameter<config, chainId>> &\n    ConnectorParameter & {\n      /** @deprecated */\n      __mode?: 'prepared'\n    }\n>\n\nexport type WriteContractReturnType = viem_WriteContractReturnType\n\nexport type WriteContractErrorType =\n  // getConnectorClient()\n  | GetConnectorClientErrorType\n  // base\n  | BaseErrorType\n  | ErrorType\n  // viem\n  | viem_WriteContractErrorType\n\n/** https://wagmi.sh/core/api/actions/writeContract */\nexport async function writeContract<\n  config extends Config,\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  chainId extends config['chains'][number]['id'],\n>(\n  config: config,\n  parameters: WriteContractParameters<abi, functionName, args, config, chainId>,\n): Promise<WriteContractReturnType> {\n  const { account, chainId, connector, ...request } = parameters\n\n  let client: Client\n  if (typeof account === 'object' && account?.type === 'local')\n    client = config.getClient({ chainId })\n  else\n    client = await getConnectorClient(config, {\n      account: account ?? undefined,\n      assertChainId: false,\n      chainId,\n      connector,\n    })\n\n  const action = getAction(client, viem_writeContract, 'writeContract')\n  const hash = await action({\n    ...(request as any),\n    ...(account ? { account } : {}),\n    chain: chainId ? { id: chainId } : null,\n  })\n\n  return hash\n}\n"],"names":[],"mappings":";;;;AAQA,OAAO,EAIL,aAAa,IAAI,kBAAkB,GACpC,MAAM,cAAc,CAAA;AAUrB,OAAO,EAAE,SAAS,EAAE,MAAM,uBAAuB,CAAA;AACjD,OAAO,EAEL,kBAAkB,GACnB,MAAM,yBAAyB,CAAA;;;;AAoDzB,KAAK,UAAU,aAAa,CAWjC,MAAc,EACd,UAA6E;IAE7E,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,GAAG,UAAU,CAAA;IAE9D,IAAI,MAAc,CAAA;IAClB,IAAI,OAAO,OAAO,KAAK,QAAQ,IAAI,OAAO,EAAE,IAAI,KAAK,OAAO,EAC1D,MAAM,GAAG,MAAM,CAAC,SAAS,CAAC;QAAE,OAAO;IAAA,CAAE,CAAC,CAAA;SAEtC,MAAM,GAAG,UAAM,+PAAkB,EAAC,MAAM,EAAE;QACxC,OAAO,EAAE,OAAO,IAAI,SAAS;QAC7B,aAAa,EAAE,KAAK;QACpB,OAAO;QACP,SAAS;KACV,CAAC,CAAA;IAEJ,MAAM,MAAM,OAAG,2OAAS,EAAC,MAAM,EAAE,6OAAkB,EAAE,eAAe,CAAC,CAAA;IACrE,MAAM,IAAI,GAAG,MAAM,MAAM,CAAC;QACxB,GAAI,OAAe;QACnB,GAAG,AAAC,OAAO,CAAC,CAAC,CAAC;YAAE,OAAO;QAAA,CAAE,CAAC,CAAC,CAAC,CAAA,CAAE,CAAC;QAC/B,KAAK,EAAE,OAAO,CAAC,CAAC,CAAC;YAAE,EAAE,EAAE,OAAO;QAAA,CAAE,CAAC,CAAC,CAAC,IAAI;KACxC,CAAC,CAAA;IAEF,OAAO,IAAI,CAAA;AACb,CAAC"}},
    {"offset": {"line": 412, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/@wagmi/core/dist/esm/query/writeContract.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/%40wagmi/core/src/query/writeContract.ts"],"sourcesContent":["import type { MutateOptions, MutationOptions } from '@tanstack/query-core'\nimport type { Abi, ContractFunctionArgs, ContractFunctionName } from 'viem'\n\nimport {\n  type WriteContractErrorType,\n  type WriteContractParameters,\n  type WriteContractReturnType,\n  writeContract,\n} from '../actions/writeContract.js'\nimport type { Config } from '../createConfig.js'\nimport type { Compute } from '../types/utils.js'\n\nexport function writeContractMutationOptions<config extends Config>(\n  config: config,\n) {\n  return {\n    mutationFn(variables) {\n      return writeContract(config, variables)\n    },\n    mutationKey: ['writeContract'],\n  } as const satisfies MutationOptions<\n    WriteContractData,\n    WriteContractErrorType,\n    WriteContractVariables<\n      Abi,\n      string,\n      readonly unknown[],\n      config,\n      config['chains'][number]['id']\n    >\n  >\n}\n\nexport type WriteContractData = Compute<WriteContractReturnType>\n\nexport type WriteContractVariables<\n  abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n  ///\n  allFunctionNames = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n> = WriteContractParameters<\n  abi,\n  functionName,\n  args,\n  config,\n  chainId,\n  allFunctionNames\n>\n\nexport type WriteContractMutate<config extends Config, context = unknown> = <\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  chainId extends config['chains'][number]['id'],\n>(\n  variables: WriteContractVariables<abi, functionName, args, config, chainId>,\n  options?:\n    | MutateOptions<\n        WriteContractData,\n        WriteContractErrorType,\n        WriteContractVariables<\n          abi,\n          functionName,\n          args,\n          config,\n          chainId,\n          // use `functionName` to make sure it's not union of all possible function names\n          functionName\n        >,\n        context\n      >\n    | undefined,\n) => void\n\nexport type WriteContractMutateAsync<\n  config extends Config,\n  context = unknown,\n> = <\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  chainId extends config['chains'][number]['id'],\n>(\n  variables: WriteContractVariables<abi, functionName, args, config, chainId>,\n  options?:\n    | MutateOptions<\n        WriteContractData,\n        WriteContractErrorType,\n        WriteContractVariables<\n          abi,\n          functionName,\n          args,\n          config,\n          chainId,\n          // use `functionName` to make sure it's not union of all possible function names\n          functionName\n        >,\n        context\n      >\n    | undefined,\n) => Promise<WriteContractData>\n"],"names":[],"mappings":";;;;AAGA,OAAO,EAIL,aAAa,GACd,MAAM,6BAA6B,CAAA;;AAI9B,SAAU,4BAA4B,CAC1C,MAAc;IAEd,OAAO;QACL,UAAU,EAAC,SAAS;YAClB,WAAO,qPAAa,EAAC,MAAM,EAAE,SAAS,CAAC,CAAA;QACzC,CAAC;QACD,WAAW,EAAE;YAAC,eAAe;SAAC;KAW/B,CAAA;AACH,CAAC"}},
    {"offset": {"line": 432, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/wagmi/dist/esm/hooks/useWriteContract.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/wagmi/src/hooks/useWriteContract.ts"],"sourcesContent":["'use client'\n\nimport { useMutation } from '@tanstack/react-query'\nimport type {\n  Config,\n  ResolvedRegister,\n  WriteContractErrorType,\n} from '@wagmi/core'\nimport {\n  type WriteContractData,\n  type WriteContractMutate,\n  type WriteContractMutateAsync,\n  type WriteContractVariables,\n  writeContractMutationOptions,\n} from '@wagmi/core/query'\nimport type { Abi } from 'viem'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport type {\n  UseMutationParameters,\n  UseMutationReturnType,\n} from '../utils/query.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseWriteContractParameters<\n  config extends Config = Config,\n  context = unknown,\n> = ConfigParameter<config> & {\n  mutation?:\n    | UseMutationParameters<\n        WriteContractData,\n        WriteContractErrorType,\n        WriteContractVariables<\n          Abi,\n          string,\n          readonly unknown[],\n          config,\n          config['chains'][number]['id']\n        >,\n        context\n      >\n    | undefined\n}\n\nexport type UseWriteContractReturnType<\n  config extends Config = Config,\n  context = unknown,\n> = UseMutationReturnType<\n  WriteContractData,\n  WriteContractErrorType,\n  WriteContractVariables<\n    Abi,\n    string,\n    readonly unknown[],\n    config,\n    config['chains'][number]['id']\n  >,\n  context\n> & {\n  writeContract: WriteContractMutate<config, context>\n  writeContractAsync: WriteContractMutateAsync<config, context>\n}\n\n/** https://wagmi.sh/react/api/hooks/useWriteContract */\nexport function useWriteContract<\n  config extends Config = ResolvedRegister['config'],\n  context = unknown,\n>(\n  parameters: UseWriteContractParameters<config, context> = {},\n): UseWriteContractReturnType<config, context> {\n  const { mutation } = parameters\n\n  const config = useConfig(parameters)\n\n  const mutationOptions = writeContractMutationOptions(config)\n  const { mutate, mutateAsync, ...result } = useMutation({\n    ...mutation,\n    ...mutationOptions,\n  })\n\n  type Return = UseWriteContractReturnType<config, context>\n  return {\n    ...result,\n    writeContract: mutate as Return['writeContract'],\n    writeContractAsync: mutateAsync as Return['writeContractAsync'],\n  }\n}\n"],"names":[],"mappings":";;;;AAEA,OAAO,EAAE,WAAW,EAAE,MAAM,uBAAuB,CAAA;AAMnD,OAAO,EAKL,4BAA4B,GAC7B,MAAM,mBAAmB,CAAA;AAQ1B,OAAO,EAAE,SAAS,EAAE,MAAM,gBAAgB,CAAA;AAtB1C,YAAY,CAAA;;;;AAgEN,SAAU,gBAAgB,CAI9B,aAA0D,CAAA,CAAE;IAE5D,MAAM,EAAE,QAAQ,EAAE,GAAG,UAAU,CAAA;IAE/B,MAAM,MAAM,OAAG,iOAAS,EAAC,UAAU,CAAC,CAAA;IAEpC,MAAM,eAAe,OAAG,kQAA4B,EAAC,MAAM,CAAC,CAAA;IAC5D,MAAM,EAAE,MAAM,EAAE,WAAW,EAAE,GAAG,MAAM,EAAE,OAAG,uPAAW,EAAC;QACrD,GAAG,QAAQ;QACX,GAAG,eAAe;KACnB,CAAC,CAAA;IAGF,OAAO;QACL,GAAG,MAAM;QACT,aAAa,EAAE,MAAiC;QAChD,kBAAkB,EAAE,WAA2C;KAChE,CAAA;AACH,CAAC"}},
    {"offset": {"line": 461, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/@wagmi/core/dist/esm/actions/waitForTransactionReceipt.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/%40wagmi/core/src/actions/waitForTransactionReceipt.ts"],"sourcesContent":["import type { Chain } from 'viem'\nimport { hexToString } from 'viem'\nimport {\n  call,\n  getTransaction,\n  type WaitForTransactionReceiptErrorType as viem_WaitForTransactionReceiptErrorType,\n  type WaitForTransactionReceiptParameters as viem_WaitForTransactionReceiptParameters,\n  type WaitForTransactionReceiptReturnType as viem_WaitForTransactionReceiptReturnType,\n  waitForTransactionReceipt as viem_waitForTransactionReceipt,\n} from 'viem/actions'\n\nimport type { Config } from '../createConfig.js'\nimport type { SelectChains } from '../types/chain.js'\nimport type { ChainIdParameter } from '../types/properties.js'\nimport type { Compute, IsNarrowable } from '../types/utils.js'\nimport { getAction } from '../utils/getAction.js'\n\nexport type WaitForTransactionReceiptParameters<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n> = Compute<\n  viem_WaitForTransactionReceiptParameters & ChainIdParameter<config, chainId>\n>\n\nexport type WaitForTransactionReceiptReturnType<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  ///\n  chains extends readonly Chain[] = SelectChains<config, chainId>,\n> = Compute<\n  {\n    [key in keyof chains]: viem_WaitForTransactionReceiptReturnType<\n      IsNarrowable<chains[key], Chain> extends true ? chains[key] : undefined\n    > & { chainId: chains[key]['id'] }\n  }[number]\n>\n\nexport type WaitForTransactionReceiptErrorType =\n  viem_WaitForTransactionReceiptErrorType\n\nexport async function waitForTransactionReceipt<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n>(\n  config: config,\n  parameters: WaitForTransactionReceiptParameters<config, chainId>,\n): Promise<WaitForTransactionReceiptReturnType<config, chainId>> {\n  const { chainId, timeout = 0, ...rest } = parameters\n\n  const client = config.getClient({ chainId })\n  const action = getAction(\n    client,\n    viem_waitForTransactionReceipt,\n    'waitForTransactionReceipt',\n  )\n  const receipt = await action({ ...rest, timeout })\n\n  if (receipt.status === 'reverted') {\n    const action_getTransaction = getAction(\n      client,\n      getTransaction,\n      'getTransaction',\n    )\n    const { from: account, ...txn } = await action_getTransaction({\n      hash: receipt.transactionHash,\n    })\n    const action_call = getAction(client, call, 'call')\n    const code = await action_call({\n      ...(txn as any),\n      account,\n      data: txn.input,\n      gasPrice: txn.type !== 'eip1559' ? txn.gasPrice : undefined,\n      maxFeePerGas: txn.type === 'eip1559' ? txn.maxFeePerGas : undefined,\n      maxPriorityFeePerGas:\n        txn.type === 'eip1559' ? txn.maxPriorityFeePerGas : undefined,\n    })\n    const reason = code?.data\n      ? hexToString(`0x${code.data.substring(138)}`)\n      : 'unknown reason'\n    throw new Error(reason)\n  }\n\n  return {\n    ...receipt,\n    chainId: client.chain.id,\n  } as WaitForTransactionReceiptReturnType<config, chainId>\n}\n"],"names":[],"mappings":";;;;AACA,OAAO,EAAE,WAAW,EAAE,MAAM,MAAM,CAAA;;;AAClC,OAAO,EACL,IAAI,EACJ,cAAc,EAId,yBAAyB,IAAI,8BAA8B,GAC5D,MAAM,cAAc,CAAA;AAMrB,OAAO,EAAE,SAAS,EAAE,MAAM,uBAAuB,CAAA;;;;AA2B1C,KAAK,UAAU,yBAAyB,CAI7C,MAAc,EACd,UAAgE;IAEhE,MAAM,EAAE,OAAO,EAAE,OAAO,GAAG,CAAC,EAAE,GAAG,IAAI,EAAE,GAAG,UAAU,CAAA;IAEpD,MAAM,MAAM,GAAG,MAAM,CAAC,SAAS,CAAC;QAAE,OAAO;IAAA,CAAE,CAAC,CAAA;IAC5C,MAAM,MAAM,OAAG,2OAAS,EACtB,MAAM,EACN,qQAA8B,EAC9B,2BAA2B,CAC5B,CAAA;IACD,MAAM,OAAO,GAAG,MAAM,MAAM,CAAC;QAAE,GAAG,IAAI;QAAE,OAAO;IAAA,CAAE,CAAC,CAAA;IAElD,IAAI,OAAO,CAAC,MAAM,KAAK,UAAU,EAAE,CAAC;QAClC,MAAM,qBAAqB,OAAG,2OAAS,EACrC,MAAM,EACN,+OAAc,EACd,gBAAgB,CACjB,CAAA;QACD,MAAM,EAAE,IAAI,EAAE,OAAO,EAAE,GAAG,GAAG,EAAE,GAAG,MAAM,qBAAqB,CAAC;YAC5D,IAAI,EAAE,OAAO,CAAC,eAAe;SAC9B,CAAC,CAAA;QACF,MAAM,WAAW,OAAG,2OAAS,EAAC,MAAM,EAAE,2NAAI,EAAE,MAAM,CAAC,CAAA;QACnD,MAAM,IAAI,GAAG,MAAM,WAAW,CAAC;YAC7B,GAAI,GAAW;YACf,OAAO;YACP,IAAI,EAAE,GAAG,CAAC,KAAK;YACf,QAAQ,EAAE,GAAG,CAAC,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS;YAC3D,YAAY,EAAE,GAAG,CAAC,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC,CAAC,SAAS;YACnE,oBAAoB,EAClB,GAAG,CAAC,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,oBAAoB,CAAC,CAAC,CAAC,SAAS;SAChE,CAAC,CAAA;QACF,MAAM,MAAM,GAAG,IAAI,EAAE,IAAI,OACrB,qOAAW,EAAC,CAAA,EAAA,EAAK,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,CAAC,GAC5C,gBAAgB,CAAA;QACpB,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,CAAA;IACzB,CAAC;IAED,OAAO;QACL,GAAG,OAAO;QACV,OAAO,EAAE,MAAM,CAAC,KAAK,CAAC,EAAE;KAC+B,CAAA;AAC3D,CAAC"}},
    {"offset": {"line": 509, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/@wagmi/core/dist/esm/query/waitForTransactionReceipt.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/%40wagmi/core/src/query/waitForTransactionReceipt.ts"],"sourcesContent":["import type { QueryOptions } from '@tanstack/query-core'\n\nimport {\n  type WaitForTransactionReceiptErrorType,\n  type WaitForTransactionReceiptParameters,\n  type WaitForTransactionReceiptReturnType,\n  waitForTransactionReceipt,\n} from '../actions/waitForTransactionReceipt.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type WaitForTransactionReceiptOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = Compute<\n  ExactPartial<WaitForTransactionReceiptParameters<config, chainId>> &\n    ScopeKeyParameter\n>\n\nexport function waitForTransactionReceiptQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n>(\n  config: config,\n  options: WaitForTransactionReceiptOptions<config, chainId> = {},\n) {\n  return {\n    async queryFn({ queryKey }) {\n      const { hash, ...parameters } = queryKey[1]\n      if (!hash) throw new Error('hash is required')\n      return waitForTransactionReceipt(config, {\n        ...parameters,\n        onReplaced: options.onReplaced,\n        hash,\n      }) as unknown as Promise<\n        WaitForTransactionReceiptReturnType<config, chainId>\n      >\n    },\n    queryKey: waitForTransactionReceiptQueryKey(options),\n  } as const satisfies QueryOptions<\n    WaitForTransactionReceiptQueryFnData<config, chainId>,\n    WaitForTransactionReceiptErrorType,\n    WaitForTransactionReceiptData<config, chainId>,\n    WaitForTransactionReceiptQueryKey<config, chainId>\n  >\n}\n\nexport type WaitForTransactionReceiptQueryFnData<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = WaitForTransactionReceiptReturnType<config, chainId>\n\nexport type WaitForTransactionReceiptData<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = WaitForTransactionReceiptQueryFnData<config, chainId>\n\nexport function waitForTransactionReceiptQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n>(options: WaitForTransactionReceiptOptions<config, chainId> = {}) {\n  const { onReplaced: _, ...rest } = options\n  return ['waitForTransactionReceipt', filterQueryOptions(rest)] as const\n}\n\nexport type WaitForTransactionReceiptQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = ReturnType<typeof waitForTransactionReceiptQueryKey<config, chainId>>\n"],"names":[],"mappings":";;;;;;AAEA,OAAO,EAIL,yBAAyB,GAC1B,MAAM,yCAAyC,CAAA;AAIhD,OAAO,EAAE,kBAAkB,EAAE,MAAM,YAAY,CAAA;;;AAUzC,SAAU,qCAAqC,CAInD,MAAc,EACd,UAA6D,CAAA,CAAE;IAE/D,OAAO;QACL,KAAK,CAAC,OAAO,EAAC,EAAE,QAAQ,EAAE;YACxB,MAAM,EAAE,IAAI,EAAE,GAAG,UAAU,EAAE,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAA;YAC3C,IAAI,CAAC,IAAI,EAAE,MAAM,IAAI,KAAK,CAAC,kBAAkB,CAAC,CAAA;YAC9C,WAAO,6QAAyB,EAAC,MAAM,EAAE;gBACvC,GAAG,UAAU;gBACb,UAAU,EAAE,OAAO,CAAC,UAAU;gBAC9B,IAAI;aACL,CAEA,CAAA;QACH,CAAC;QACD,QAAQ,EAAE,iCAAiC,CAAC,OAAO,CAAC;KAMrD,CAAA;AACH,CAAC;AAYK,SAAU,iCAAiC,CAG/C,UAA6D,CAAA,CAAE;IAC/D,MAAM,EAAE,UAAU,EAAE,CAAC,EAAE,GAAG,IAAI,EAAE,GAAG,OAAO,CAAA;IAC1C,OAAO;QAAC,2BAA2B;YAAE,gPAAkB,EAAC,IAAI,CAAC;KAAU,CAAA;AACzE,CAAC"}},
    {"offset": {"line": 544, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/wagmi/dist/esm/hooks/useWaitForTransactionReceipt.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/wagmi/src/hooks/useWaitForTransactionReceipt.ts"],"sourcesContent":["'use client'\n\nimport type {\n  Config,\n  ResolvedRegister,\n  WaitForTransactionReceiptErrorType,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport {\n  type WaitForTransactionReceiptData,\n  type WaitForTransactionReceiptOptions,\n  type WaitForTransactionReceiptQueryFnData,\n  type WaitForTransactionReceiptQueryKey,\n  waitForTransactionReceiptQueryOptions,\n} from '@wagmi/core/query'\n\nimport type { ConfigParameter, QueryParameter } from '../types/properties.js'\nimport { type UseQueryReturnType, useQuery } from '../utils/query.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseWaitForTransactionReceiptParameters<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = WaitForTransactionReceiptData<config, chainId>,\n> = Compute<\n  WaitForTransactionReceiptOptions<config, chainId> &\n    ConfigParameter<config> &\n    QueryParameter<\n      WaitForTransactionReceiptQueryFnData<config, chainId>,\n      WaitForTransactionReceiptErrorType,\n      selectData,\n      WaitForTransactionReceiptQueryKey<config, chainId>\n    >\n>\n\nexport type UseWaitForTransactionReceiptReturnType<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = WaitForTransactionReceiptData<config, chainId>,\n> = UseQueryReturnType<selectData, WaitForTransactionReceiptErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useWaitForTransactionReceipt */\nexport function useWaitForTransactionReceipt<\n  config extends Config = ResolvedRegister['config'],\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = WaitForTransactionReceiptData<config, chainId>,\n>(\n  parameters: UseWaitForTransactionReceiptParameters<\n    config,\n    chainId,\n    selectData\n  > = {},\n): UseWaitForTransactionReceiptReturnType<config, chainId, selectData> {\n  const { hash, query = {} } = parameters\n\n  const config = useConfig(parameters)\n  const chainId = useChainId({ config })\n\n  const options = waitForTransactionReceiptQueryOptions(config, {\n    ...parameters,\n    chainId: parameters.chainId ?? chainId,\n  })\n  const enabled = Boolean(hash && (query.enabled ?? true))\n\n  return useQuery({\n    ...(query as any),\n    ...options,\n    enabled,\n  }) as UseWaitForTransactionReceiptReturnType<config, chainId, selectData>\n}\n"],"names":[],"mappings":";;;;AAQA,OAAO,EAKL,qCAAqC,GACtC,MAAM,mBAAmB,CAAA;AAG1B,OAAO,EAA2B,QAAQ,EAAE,MAAM,mBAAmB,CAAA;AACrE,OAAO,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAA;AAC5C,OAAO,EAAE,SAAS,EAAE,MAAM,gBAAgB,CAAA;AAnB1C,YAAY,CAAA;;;;;AA6CN,SAAU,4BAA4B,CAM1C,aAII,CAAA,CAAE;IAEN,MAAM,EAAE,IAAI,EAAE,KAAK,GAAG,CAAA,CAAE,EAAE,GAAG,UAAU,CAAA;IAEvC,MAAM,MAAM,OAAG,iOAAS,EAAC,UAAU,CAAC,CAAA;IACpC,MAAM,OAAO,OAAG,mOAAU,EAAC;QAAE,MAAM;IAAA,CAAE,CAAC,CAAA;IAEtC,MAAM,OAAO,OAAG,uRAAqC,EAAC,MAAM,EAAE;QAC5D,GAAG,UAAU;QACb,OAAO,EAAE,UAAU,CAAC,OAAO,IAAI,OAAO;KACvC,CAAC,CAAA;IACF,MAAM,OAAO,GAAG,OAAO,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO,IAAI,IAAI,CAAC,CAAC,CAAA;IAExD,WAAO,4OAAQ,EAAC;QACd,GAAI,KAAa;QACjB,GAAG,OAAO;QACV,OAAO;KACR,CAAwE,CAAA;AAC3E,CAAC"}},
    {"offset": {"line": 578, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/%40heroicons/react/24/outline/esm/CheckCircleIcon.js"],"sourcesContent":["import * as React from \"react\";\nfunction CheckCircleIcon({\n  title,\n  titleId,\n  ...props\n}, svgRef) {\n  return /*#__PURE__*/React.createElement(\"svg\", Object.assign({\n    xmlns: \"http://www.w3.org/2000/svg\",\n    fill: \"none\",\n    viewBox: \"0 0 24 24\",\n    strokeWidth: 1.5,\n    stroke: \"currentColor\",\n    \"aria-hidden\": \"true\",\n    \"data-slot\": \"icon\",\n    ref: svgRef,\n    \"aria-labelledby\": titleId\n  }, props), title ? /*#__PURE__*/React.createElement(\"title\", {\n    id: titleId\n  }, title) : null, /*#__PURE__*/React.createElement(\"path\", {\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\",\n    d: \"M9 12.75 11.25 15 15 9.75M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z\"\n  }));\n}\nconst ForwardRef = /*#__PURE__*/ React.forwardRef(CheckCircleIcon);\nexport default ForwardRef;"],"names":[],"mappings":";;;;AAAA;;AACA,SAAS,gBAAgB,EACvB,KAAK,EACL,OAAO,EACP,GAAG,OACJ,EAAE,MAAM;IACP,OAAO,WAAW,GAAE,qOAAmB,CAAC,OAAO,OAAO,MAAM,CAAC;QAC3D,OAAO;QACP,MAAM;QACN,SAAS;QACT,aAAa;QACb,QAAQ;QACR,eAAe;QACf,aAAa;QACb,KAAK;QACL,mBAAmB;IACrB,GAAG,QAAQ,QAAQ,WAAW,GAAE,qOAAmB,CAAC,SAAS;QAC3D,IAAI;IACN,GAAG,SAAS,MAAM,WAAW,GAAE,qOAAmB,CAAC,QAAQ;QACzD,eAAe;QACf,gBAAgB;QAChB,GAAG;IACL;AACF;AACA,MAAM,aAAa,WAAW,GAAG,kOAAgB,CAAC;uCACnC","ignoreList":[0]}},
    {"offset": {"line": 618, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/%40heroicons/react/24/outline/esm/XCircleIcon.js"],"sourcesContent":["import * as React from \"react\";\nfunction XCircleIcon({\n  title,\n  titleId,\n  ...props\n}, svgRef) {\n  return /*#__PURE__*/React.createElement(\"svg\", Object.assign({\n    xmlns: \"http://www.w3.org/2000/svg\",\n    fill: \"none\",\n    viewBox: \"0 0 24 24\",\n    strokeWidth: 1.5,\n    stroke: \"currentColor\",\n    \"aria-hidden\": \"true\",\n    \"data-slot\": \"icon\",\n    ref: svgRef,\n    \"aria-labelledby\": titleId\n  }, props), title ? /*#__PURE__*/React.createElement(\"title\", {\n    id: titleId\n  }, title) : null, /*#__PURE__*/React.createElement(\"path\", {\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\",\n    d: \"m9.75 9.75 4.5 4.5m0-4.5-4.5 4.5M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z\"\n  }));\n}\nconst ForwardRef = /*#__PURE__*/ React.forwardRef(XCircleIcon);\nexport default ForwardRef;"],"names":[],"mappings":";;;;AAAA;;AACA,SAAS,YAAY,EACnB,KAAK,EACL,OAAO,EACP,GAAG,OACJ,EAAE,MAAM;IACP,OAAO,WAAW,GAAE,qOAAmB,CAAC,OAAO,OAAO,MAAM,CAAC;QAC3D,OAAO;QACP,MAAM;QACN,SAAS;QACT,aAAa;QACb,QAAQ;QACR,eAAe;QACf,aAAa;QACb,KAAK;QACL,mBAAmB;IACrB,GAAG,QAAQ,QAAQ,WAAW,GAAE,qOAAmB,CAAC,SAAS;QAC3D,IAAI;IACN,GAAG,SAAS,MAAM,WAAW,GAAE,qOAAmB,CAAC,QAAQ;QACzD,eAAe;QACf,gBAAgB;QAChB,GAAG;IACL;AACF;AACA,MAAM,aAAa,WAAW,GAAG,kOAAgB,CAAC;uCACnC","ignoreList":[0]}},
    {"offset": {"line": 658, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/%40heroicons/react/24/outline/esm/ClockIcon.js"],"sourcesContent":["import * as React from \"react\";\nfunction ClockIcon({\n  title,\n  titleId,\n  ...props\n}, svgRef) {\n  return /*#__PURE__*/React.createElement(\"svg\", Object.assign({\n    xmlns: \"http://www.w3.org/2000/svg\",\n    fill: \"none\",\n    viewBox: \"0 0 24 24\",\n    strokeWidth: 1.5,\n    stroke: \"currentColor\",\n    \"aria-hidden\": \"true\",\n    \"data-slot\": \"icon\",\n    ref: svgRef,\n    \"aria-labelledby\": titleId\n  }, props), title ? /*#__PURE__*/React.createElement(\"title\", {\n    id: titleId\n  }, title) : null, /*#__PURE__*/React.createElement(\"path\", {\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\",\n    d: \"M12 6v6h4.5m4.5 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z\"\n  }));\n}\nconst ForwardRef = /*#__PURE__*/ React.forwardRef(ClockIcon);\nexport default ForwardRef;"],"names":[],"mappings":";;;;AAAA;;AACA,SAAS,UAAU,EACjB,KAAK,EACL,OAAO,EACP,GAAG,OACJ,EAAE,MAAM;IACP,OAAO,WAAW,GAAE,qOAAmB,CAAC,OAAO,OAAO,MAAM,CAAC;QAC3D,OAAO;QACP,MAAM;QACN,SAAS;QACT,aAAa;QACb,QAAQ;QACR,eAAe;QACf,aAAa;QACb,KAAK;QACL,mBAAmB;IACrB,GAAG,QAAQ,QAAQ,WAAW,GAAE,qOAAmB,CAAC,SAAS;QAC3D,IAAI;IACN,GAAG,SAAS,MAAM,WAAW,GAAE,qOAAmB,CAAC,QAAQ;QACzD,eAAe;QACf,gBAAgB;QAChB,GAAG;IACL;AACF;AACA,MAAM,aAAa,WAAW,GAAG,kOAAgB,CAAC;uCACnC","ignoreList":[0]}},
    {"offset": {"line": 698, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/%40heroicons/react/24/outline/esm/ExclamationTriangleIcon.js"],"sourcesContent":["import * as React from \"react\";\nfunction ExclamationTriangleIcon({\n  title,\n  titleId,\n  ...props\n}, svgRef) {\n  return /*#__PURE__*/React.createElement(\"svg\", Object.assign({\n    xmlns: \"http://www.w3.org/2000/svg\",\n    fill: \"none\",\n    viewBox: \"0 0 24 24\",\n    strokeWidth: 1.5,\n    stroke: \"currentColor\",\n    \"aria-hidden\": \"true\",\n    \"data-slot\": \"icon\",\n    ref: svgRef,\n    \"aria-labelledby\": titleId\n  }, props), title ? /*#__PURE__*/React.createElement(\"title\", {\n    id: titleId\n  }, title) : null, /*#__PURE__*/React.createElement(\"path\", {\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\",\n    d: \"M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126ZM12 15.75h.007v.008H12v-.008Z\"\n  }));\n}\nconst ForwardRef = /*#__PURE__*/ React.forwardRef(ExclamationTriangleIcon);\nexport default ForwardRef;"],"names":[],"mappings":";;;;AAAA;;AACA,SAAS,wBAAwB,EAC/B,KAAK,EACL,OAAO,EACP,GAAG,OACJ,EAAE,MAAM;IACP,OAAO,WAAW,GAAE,qOAAmB,CAAC,OAAO,OAAO,MAAM,CAAC;QAC3D,OAAO;QACP,MAAM;QACN,SAAS;QACT,aAAa;QACb,QAAQ;QACR,eAAe;QACf,aAAa;QACb,KAAK;QACL,mBAAmB;IACrB,GAAG,QAAQ,QAAQ,WAAW,GAAE,qOAAmB,CAAC,SAAS;QAC3D,IAAI;IACN,GAAG,SAAS,MAAM,WAAW,GAAE,qOAAmB,CAAC,QAAQ;QACzD,eAAe;QACf,gBAAgB;QAChB,GAAG;IACL;AACF;AACA,MAAM,aAAa,WAAW,GAAG,kOAAgB,CAAC;uCACnC","ignoreList":[0]}},
    {"offset": {"line": 738, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/_esm/actions/wallet/addChain.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/actions/wallet/addChain.ts"],"sourcesContent":["import type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\n\nexport type AddChainParameters = {\n  /** The chain to add to the wallet. */\n  chain: Chain\n}\n\nexport type AddChainErrorType =\n  | RequestErrorType\n  | NumberToHexErrorType\n  | ErrorType\n\n/**\n * Adds an EVM chain to the wallet.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/addChain\n * - JSON-RPC Methods: [`eth_addEthereumChain`](https://eips.ethereum.org/EIPS/eip-3085)\n *\n * @param client - Client to use\n * @param parameters - {@link AddChainParameters}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { optimism } from 'viem/chains'\n * import { addChain } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   transport: custom(window.ethereum),\n * })\n * await addChain(client, { chain: optimism })\n */\nexport async function addChain<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(client: Client<Transport, chain, account>, { chain }: AddChainParameters) {\n  const { id, name, nativeCurrency, rpcUrls, blockExplorers } = chain\n  await client.request(\n    {\n      method: 'wallet_addEthereumChain',\n      params: [\n        {\n          chainId: numberToHex(id),\n          chainName: name,\n          nativeCurrency,\n          rpcUrls: rpcUrls.default.http,\n          blockExplorerUrls: blockExplorers\n            ? Object.values(blockExplorers).map(({ url }) => url)\n            : undefined,\n        },\n      ],\n    },\n    { dedupe: true, retryCount: 0 },\n  )\n}\n"],"names":[],"mappings":";;;;AAMA,OAAO,EAEL,WAAW,GACZ,MAAM,+BAA+B,CAAA;;AA+B/B,KAAK,UAAU,QAAQ,CAG5B,MAAyC,EAAE,EAAE,KAAK,EAAsB;IACxE,MAAM,EAAE,EAAE,EAAE,IAAI,EAAE,cAAc,EAAE,OAAO,EAAE,cAAc,EAAE,GAAG,KAAK,CAAA;IACnE,MAAM,MAAM,CAAC,OAAO,CAClB;QACE,MAAM,EAAE,yBAAyB;QACjC,MAAM,EAAE;YACN;gBACE,OAAO,MAAE,mOAAW,EAAC,EAAE,CAAC;gBACxB,SAAS,EAAE,IAAI;gBACf,cAAc;gBACd,OAAO,EAAE,OAAO,CAAC,OAAO,CAAC,IAAI;gBAC7B,iBAAiB,EAAE,cAAc,GAC7B,MAAM,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,GAAG,EAAE,EAAE,CAAG,CAAD,EAAI,CAAC,GACnD,SAAS;aACd;SACF;KACF,EACD;QAAE,MAAM,EAAE,IAAI;QAAE,UAAU,EAAE,CAAC;IAAA,CAAE,CAChC,CAAA;AACH,CAAC"}},
    {"offset": {"line": 766, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/_esm/actions/wallet/deployContract.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/actions/wallet/deployContract.ts"],"sourcesContent":["import type { Abi } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain, GetChainParameter } from '../../types/chain.js'\nimport type { ContractConstructorArgs } from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { UnionEvaluate, UnionOmit } from '../../types/utils.js'\nimport { encodeDeployData } from '../../utils/abi/encodeDeployData.js'\nimport {\n  type SendTransactionErrorType,\n  type SendTransactionParameters,\n  type SendTransactionReturnType,\n  sendTransaction,\n} from './sendTransaction.js'\n\nexport type DeployContractParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  ///\n  allArgs = ContractConstructorArgs<abi>,\n> = UnionOmit<\n  SendTransactionParameters<chain, account, chainOverride>,\n  'accessList' | 'chain' | 'to' | 'data'\n> &\n  GetChainParameter<chain, chainOverride> &\n  UnionEvaluate<\n    readonly [] extends allArgs\n      ? { args?: allArgs | undefined }\n      : { args: allArgs }\n  > & {\n    abi: abi\n    bytecode: Hex\n  }\n\nexport type DeployContractReturnType = SendTransactionReturnType\n\nexport type DeployContractErrorType = SendTransactionErrorType | ErrorType\n\n/**\n * Deploys a contract to the network, given bytecode and constructor arguments.\n *\n * - Docs: https://viem.sh/docs/contract/deployContract\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_deploying-contracts\n *\n * @param client - Client to use\n * @param parameters - {@link DeployContractParameters}\n * @returns The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link DeployContractReturnType}\n *\n * @example\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { deployContract } from 'viem/contract'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const hash = await deployContract(client, {\n *   abi: [],\n *   account: '0x…,\n *   bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',\n * })\n */\nexport function deployContract<\n  const abi extends Abi | readonly unknown[],\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  chainOverride extends Chain | undefined,\n>(\n  walletClient: Client<Transport, chain, account>,\n  parameters: DeployContractParameters<abi, chain, account, chainOverride>,\n): Promise<DeployContractReturnType> {\n  const { abi, args, bytecode, ...request } =\n    parameters as DeployContractParameters\n  const calldata = encodeDeployData({ abi, args, bytecode })\n  return sendTransaction(walletClient, {\n    ...request,\n    ...(request.authorizationList ? { to: null } : {}),\n    data: calldata,\n  } as unknown as SendTransactionParameters<chain, account, chainOverride>)\n}\n"],"names":[],"mappings":";;;;AAUA,OAAO,EAAE,gBAAgB,EAAE,MAAM,qCAAqC,CAAA;AACtE,OAAO,EAIL,eAAe,GAChB,MAAM,sBAAsB,CAAA;;;AAsDvB,SAAU,cAAc,CAM5B,YAA+C,EAC/C,UAAwE;IAExE,MAAM,EAAE,GAAG,EAAE,IAAI,EAAE,QAAQ,EAAE,GAAG,OAAO,EAAE,GACvC,UAAsC,CAAA;IACxC,MAAM,QAAQ,OAAG,8OAAgB,EAAC;QAAE,GAAG;QAAE,IAAI;QAAE,QAAQ;IAAA,CAAE,CAAC,CAAA;IAC1D,WAAO,iPAAe,EAAC,YAAY,EAAE;QACnC,GAAG,OAAO;QACV,GAAG,AAAC,OAAO,CAAC,iBAAiB,CAAC,CAAC,CAAC;YAAE,EAAE,EAAE,IAAI;QAAA,CAAE,CAAC,CAAC,CAAC,CAAA,CAAE,CAAC;QAClD,IAAI,EAAE,QAAQ;KACwD,CAAC,CAAA;AAC3E,CAAC"}},
    {"offset": {"line": 793, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/_esm/actions/wallet/getAddresses.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/actions/wallet/getAddresses.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport {\n  type ChecksumAddressErrorType,\n  checksumAddress,\n} from '../../utils/address/getAddress.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type GetAddressesReturnType = Address[]\n\nexport type GetAddressesErrorType =\n  | RequestErrorType\n  | ChecksumAddressErrorType\n  | ErrorType\n\n/**\n * Returns a list of account addresses owned by the wallet or client.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/getAddresses\n * - JSON-RPC Methods: [`eth_accounts`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_accounts)\n *\n * @param client - Client to use\n * @returns List of account addresses owned by the wallet or client. {@link GetAddressesReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getAddresses } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const accounts = await getAddresses(client)\n */\nexport async function getAddresses<\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n>(client: Client<Transport, chain, account>): Promise<GetAddressesReturnType> {\n  if (client.account?.type === 'local') return [client.account.address]\n  const addresses = await client.request(\n    { method: 'eth_accounts' },\n    { dedupe: true },\n  )\n  return addresses.map((address) => checksumAddress(address))\n}\n"],"names":[],"mappings":";;;;AAOA,OAAO,EAEL,eAAe,GAChB,MAAM,mCAAmC,CAAA;;AA8BnC,KAAK,UAAU,YAAY,CAGhC,MAAyC;IACzC,IAAI,MAAM,CAAC,OAAO,EAAE,IAAI,KAAK,OAAO,EAAE,OAAO;QAAC,MAAM,CAAC,OAAO,CAAC,OAAO;KAAC,CAAA;IACrE,MAAM,SAAS,GAAG,MAAM,MAAM,CAAC,OAAO,CACpC;QAAE,MAAM,EAAE,cAAc;IAAA,CAAE,EAC1B;QAAE,MAAM,EAAE,IAAI;IAAA,CAAE,CACjB,CAAA;IACD,OAAO,SAAS,CAAC,GAAG,CAAC,CAAC,OAAO,EAAE,EAAE,GAAC,2OAAe,EAAC,OAAO,CAAC,CAAC,CAAA;AAC7D,CAAC"}},
    {"offset": {"line": 814, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/_esm/actions/wallet/sendCalls.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/actions/wallet/sendCalls.ts"],"sourcesContent":["import type { Address, Narrow } from 'abitype'\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { BaseError } from '../../errors/base.js'\nimport {\n  AtomicityNotSupportedError,\n  UnsupportedNonOptionalCapabilityError,\n} from '../../errors/rpc.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account, GetAccountParameter } from '../../types/account.js'\nimport type { Call, Calls } from '../../types/calls.js'\nimport type { ExtractCapabilities } from '../../types/capabilities.js'\nimport type { Chain, DeriveChain } from '../../types/chain.js'\nimport type { WalletSendCallsParameters } from '../../types/eip1193.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { Prettify } from '../../types/utils.js'\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { concat } from '../../utils/data/concat.js'\nimport { hexToBigInt } from '../../utils/encoding/fromHex.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\nimport { getTransactionError } from '../../utils/errors/getTransactionError.js'\nimport { sendTransaction } from './sendTransaction.js'\n\nexport const fallbackMagicIdentifier =\n  '0x5792579257925792579257925792579257925792579257925792579257925792'\nexport const fallbackTransactionErrorMagicIdentifier = numberToHex(0, {\n  size: 32,\n})\n\nexport type SendCallsParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  calls extends readonly unknown[] = readonly unknown[],\n  //\n  _chain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = {\n  chain?: chainOverride | Chain | undefined\n  calls: Calls<Narrow<calls>>\n  capabilities?: ExtractCapabilities<'sendCalls', 'Request'> | undefined\n  experimental_fallback?: boolean | undefined\n  experimental_fallbackDelay?: number | undefined\n  forceAtomic?: boolean | undefined\n  id?: string | undefined\n  version?: WalletSendCallsParameters[number]['version'] | undefined\n} & GetAccountParameter<account, Account | Address, false, true>\n\nexport type SendCallsReturnType = Prettify<{\n  capabilities?: ExtractCapabilities<'sendCalls', 'ReturnType'> | undefined\n  id: string\n}>\n\nexport type SendCallsErrorType = RequestErrorType | ErrorType\n\n/**\n * Requests the connected wallet to send a batch of calls.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/sendCalls\n * - JSON-RPC Methods: [`wallet_sendCalls`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @returns Transaction identifier. {@link SendCallsReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { sendCalls } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const id = await sendCalls(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   calls: [\n *     {\n *       data: '0xdeadbeef',\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *     },\n *     {\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *       value: 69420n,\n *     },\n *   ],\n * })\n */\nexport async function sendCalls<\n  const calls extends readonly unknown[],\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: SendCallsParameters<chain, account, chainOverride, calls>,\n): Promise<SendCallsReturnType> {\n  const {\n    account: account_ = client.account,\n    capabilities,\n    chain = client.chain,\n    experimental_fallback,\n    experimental_fallbackDelay = 32,\n    forceAtomic = false,\n    id,\n    version = '2.0.0',\n  } = parameters\n\n  const account = account_ ? parseAccount(account_) : null\n\n  const calls = parameters.calls.map((call_: unknown) => {\n    const call = call_ as Call\n\n    const data = call.abi\n      ? encodeFunctionData({\n          abi: call.abi,\n          functionName: call.functionName,\n          args: call.args,\n        })\n      : call.data\n\n    return {\n      data: call.dataSuffix && data ? concat([data, call.dataSuffix]) : data,\n      to: call.to,\n      value: call.value ? numberToHex(call.value) : undefined,\n    }\n  })\n\n  try {\n    const response = await client.request(\n      {\n        method: 'wallet_sendCalls',\n        params: [\n          {\n            atomicRequired: forceAtomic,\n            calls,\n            capabilities,\n            chainId: numberToHex(chain!.id),\n            from: account?.address,\n            id,\n            version,\n          },\n        ],\n      },\n      { retryCount: 0 },\n    )\n    if (typeof response === 'string') return { id: response }\n    return response as never\n  } catch (err) {\n    const error = err as BaseError\n\n    // If the transport does not support EIP-5792, fall back to\n    // `eth_sendTransaction`.\n    if (\n      experimental_fallback &&\n      (error.name === 'MethodNotFoundRpcError' ||\n        error.name === 'MethodNotSupportedRpcError' ||\n        error.name === 'UnknownRpcError' ||\n        error.details\n          .toLowerCase()\n          .includes('does not exist / is not available') ||\n        error.details.toLowerCase().includes('missing or invalid. request()') ||\n        error.details\n          .toLowerCase()\n          .includes('did not match any variant of untagged enum') ||\n        error.details\n          .toLowerCase()\n          .includes('account upgraded to unsupported contract') ||\n        error.details.toLowerCase().includes('eip-7702 not supported') ||\n        error.details.toLowerCase().includes('unsupported wc_ method') ||\n        // magic.link\n        error.details\n          .toLowerCase()\n          .includes('feature toggled misconfigured') ||\n        // Trust Wallet\n        error.details\n          .toLowerCase()\n          .includes(\n            'jsonrpcengine: response has no error or result for request',\n          ))\n    ) {\n      if (capabilities) {\n        const hasNonOptionalCapability = Object.values(capabilities).some(\n          (capability) => !capability.optional,\n        )\n        if (hasNonOptionalCapability) {\n          const message =\n            'non-optional `capabilities` are not supported on fallback to `eth_sendTransaction`.'\n          throw new UnsupportedNonOptionalCapabilityError(\n            new BaseError(message, {\n              details: message,\n            }),\n          )\n        }\n      }\n      if (forceAtomic && calls.length > 1) {\n        const message =\n          '`forceAtomic` is not supported on fallback to `eth_sendTransaction`.'\n        throw new AtomicityNotSupportedError(\n          new BaseError(message, {\n            details: message,\n          }),\n        )\n      }\n\n      const promises: Promise<Hex>[] = []\n      for (const call of calls) {\n        const promise = sendTransaction(client, {\n          account,\n          chain,\n          data: call.data,\n          to: call.to,\n          value: call.value ? hexToBigInt(call.value) : undefined,\n        })\n        promises.push(promise)\n\n        // Note: some browser wallets require a small delay between transactions\n        // to prevent duplicate JSON-RPC requests.\n        if (experimental_fallbackDelay > 0)\n          await new Promise((resolve) =>\n            setTimeout(resolve, experimental_fallbackDelay),\n          )\n      }\n\n      const results = await Promise.allSettled(promises)\n      if (results.every((r) => r.status === 'rejected')) throw results[0].reason\n\n      const hashes = results.map((result) => {\n        if (result.status === 'fulfilled') return result.value\n        return fallbackTransactionErrorMagicIdentifier\n      })\n      return {\n        id: concat([\n          ...hashes,\n          numberToHex(chain!.id, { size: 32 }),\n          fallbackMagicIdentifier,\n        ]),\n      }\n    }\n\n    throw getTransactionError(err as BaseError, {\n      ...parameters,\n      account,\n      chain: parameters.chain!,\n    })\n  }\n}\n"],"names":[],"mappings":";;;;;;;;AACA,OAAO,EAAE,YAAY,EAAE,MAAM,sCAAsC,CAAA;AAGnE,OAAO,EAAE,SAAS,EAAE,MAAM,sBAAsB,CAAA;AAChD,OAAO,EACL,0BAA0B,EAC1B,qCAAqC,GACtC,MAAM,qBAAqB,CAAA;AAS5B,OAAO,EAAE,kBAAkB,EAAE,MAAM,uCAAuC,CAAA;AAE1E,OAAO,EAAE,MAAM,EAAE,MAAM,4BAA4B,CAAA;AACnD,OAAO,EAAE,WAAW,EAAE,MAAM,iCAAiC,CAAA;AAC7D,OAAO,EAAE,WAAW,EAAE,MAAM,+BAA+B,CAAA;AAC3D,OAAO,EAAE,mBAAmB,EAAE,MAAM,2CAA2C,CAAA;AAC/E,OAAO,EAAE,eAAe,EAAE,MAAM,sBAAsB,CAAA;;;;;;;;;;AAE/C,MAAM,uBAAuB,GAClC,oEAAoE,CAAA;AAC/D,MAAM,uCAAuC,OAAG,mOAAW,EAAC,CAAC,EAAE;IACpE,IAAI,EAAE,EAAE;CACT,CAAC,CAAA;AA2DK,KAAK,UAAU,SAAS,CAM7B,MAAyC,EACzC,UAAqE;IAErE,MAAM,EACJ,OAAO,EAAE,QAAQ,GAAG,MAAM,CAAC,OAAO,EAClC,YAAY,EACZ,KAAK,GAAG,MAAM,CAAC,KAAK,EACpB,qBAAqB,EACrB,0BAA0B,GAAG,EAAE,EAC/B,WAAW,GAAG,KAAK,EACnB,EAAE,EACF,OAAO,GAAG,OAAO,EAClB,GAAG,UAAU,CAAA;IAEd,MAAM,OAAO,GAAG,QAAQ,CAAC,CAAC,KAAC,2OAAY,EAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,IAAI,CAAA;IAExD,MAAM,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,KAAc,EAAE,EAAE;QACpD,MAAM,IAAI,GAAG,KAAa,CAAA;QAE1B,MAAM,IAAI,GAAG,IAAI,CAAC,GAAG,OACjB,kPAAkB,EAAC;YACjB,GAAG,EAAE,IAAI,CAAC,GAAG;YACb,YAAY,EAAE,IAAI,CAAC,YAAY;YAC/B,IAAI,EAAE,IAAI,CAAC,IAAI;SAChB,CAAC,GACF,IAAI,CAAC,IAAI,CAAA;QAEb,OAAO;YACL,IAAI,EAAE,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,CAAC,KAAC,2NAAM,EAAC;gBAAC,IAAI;gBAAE,IAAI,CAAC,UAAU;aAAC,CAAC,CAAC,CAAC,CAAC,IAAI;YACtE,EAAE,EAAE,IAAI,CAAC,EAAE;YACX,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,KAAC,mOAAW,EAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS;SACxD,CAAA;IACH,CAAC,CAAC,CAAA;IAEF,IAAI,CAAC;QACH,MAAM,QAAQ,GAAG,MAAM,MAAM,CAAC,OAAO,CACnC;YACE,MAAM,EAAE,kBAAkB;YAC1B,MAAM,EAAE;gBACN;oBACE,cAAc,EAAE,WAAW;oBAC3B,KAAK;oBACL,YAAY;oBACZ,OAAO,MAAE,mOAAW,EAAC,KAAM,CAAC,EAAE,CAAC;oBAC/B,IAAI,EAAE,OAAO,EAAE,OAAO;oBACtB,EAAE;oBACF,OAAO;iBACR;aACF;SACF,EACD;YAAE,UAAU,EAAE,CAAC;QAAA,CAAE,CAClB,CAAA;QACD,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE,OAAO;YAAE,EAAE,EAAE,QAAQ;QAAA,CAAE,CAAA;QACzD,OAAO,QAAiB,CAAA;IAC1B,CAAC,CAAC,OAAO,GAAG,EAAE,CAAC;QACb,MAAM,KAAK,GAAG,GAAgB,CAAA;QAE9B,2DAA2D;QAC3D,yBAAyB;QACzB,IACE,qBAAqB,IACrB,CAAC,KAAK,CAAC,IAAI,KAAK,wBAAwB,IACtC,KAAK,CAAC,IAAI,KAAK,4BAA4B,IAC3C,KAAK,CAAC,IAAI,KAAK,iBAAiB,IAChC,KAAK,CAAC,OAAO,CACV,WAAW,EAAE,CACb,QAAQ,CAAC,mCAAmC,CAAC,IAChD,KAAK,CAAC,OAAO,CAAC,WAAW,EAAE,CAAC,QAAQ,CAAC,+BAA+B,CAAC,IACrE,KAAK,CAAC,OAAO,CACV,WAAW,EAAE,CACb,QAAQ,CAAC,4CAA4C,CAAC,IACzD,KAAK,CAAC,OAAO,CACV,WAAW,EAAE,CACb,QAAQ,CAAC,0CAA0C,CAAC,IACvD,KAAK,CAAC,OAAO,CAAC,WAAW,EAAE,CAAC,QAAQ,CAAC,wBAAwB,CAAC,IAC9D,KAAK,CAAC,OAAO,CAAC,WAAW,EAAE,CAAC,QAAQ,CAAC,wBAAwB,CAAC,IAC9D,aAAa;QACb,KAAK,CAAC,OAAO,CACV,WAAW,EAAE,CACb,QAAQ,CAAC,+BAA+B,CAAC,IAC5C,eAAe;QACf,KAAK,CAAC,OAAO,CACV,WAAW,EAAE,CACb,QAAQ,CACP,4DAA4D,CAC7D,CAAC,EACN,CAAC;YACD,IAAI,YAAY,EAAE,CAAC;gBACjB,MAAM,wBAAwB,GAAG,MAAM,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,IAAI,CAC/D,CAAC,UAAU,EAAE,CAAG,CAAD,AAAE,UAAU,CAAC,QAAQ,CACrC,CAAA;gBACD,IAAI,wBAAwB,EAAE,CAAC;oBAC7B,MAAM,OAAO,GACX,qFAAqF,CAAA;oBACvF,MAAM,IAAI,gPAAqC,CAC7C,IAAI,qNAAS,CAAC,OAAO,EAAE;wBACrB,OAAO,EAAE,OAAO;qBACjB,CAAC,CACH,CAAA;gBACH,CAAC;YACH,CAAC;YACD,IAAI,WAAW,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBACpC,MAAM,OAAO,GACX,sEAAsE,CAAA;gBACxE,MAAM,IAAI,qOAA0B,CAClC,IAAI,qNAAS,CAAC,OAAO,EAAE;oBACrB,OAAO,EAAE,OAAO;iBACjB,CAAC,CACH,CAAA;YACH,CAAC;YAED,MAAM,QAAQ,GAAmB,EAAE,CAAA;YACnC,KAAK,MAAM,IAAI,IAAI,KAAK,CAAE,CAAC;gBACzB,MAAM,OAAO,OAAG,iPAAe,EAAC,MAAM,EAAE;oBACtC,OAAO;oBACP,KAAK;oBACL,IAAI,EAAE,IAAI,CAAC,IAAI;oBACf,EAAE,EAAE,IAAI,CAAC,EAAE;oBACX,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,KAAC,qOAAW,EAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS;iBACxD,CAAC,CAAA;gBACF,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA;gBAEtB,wEAAwE;gBACxE,0CAA0C;gBAC1C,IAAI,0BAA0B,GAAG,CAAC,EAChC,MAAM,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,CAC1B,CAD4B,SAClB,CAAC,OAAO,EAAE,0BAA0B,CAAC,CAChD,CAAA;YACL,CAAC;YAED,MAAM,OAAO,GAAG,MAAM,OAAO,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAA;YAClD,IAAI,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,AAAE,CAAC,MAAM,KAAK,UAAU,CAAC,EAAE,MAAM,OAAO,CAAC,CAAC,CAAC,CAAC,MAAM,CAAA;YAE1E,MAAM,MAAM,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE;gBACpC,IAAI,MAAM,CAAC,MAAM,KAAK,WAAW,EAAE,OAAO,MAAM,CAAC,KAAK,CAAA;gBACtD,OAAO,uCAAuC,CAAA;YAChD,CAAC,CAAC,CAAA;YACF,OAAO;gBACL,EAAE,MAAE,2NAAM,EAAC;uBACN,MAAM;wBACT,mOAAW,EAAC,KAAM,CAAC,EAAE,EAAE;wBAAE,IAAI,EAAE,EAAE;oBAAA,CAAE,CAAC;oBACpC,uBAAuB;iBACxB,CAAC;aACH,CAAA;QACH,CAAC;QAED,UAAM,uPAAmB,EAAC,GAAgB,EAAE;YAC1C,GAAG,UAAU;YACb,OAAO;YACP,KAAK,EAAE,UAAU,CAAC,KAAM;SACzB,CAAC,CAAA;IACJ,CAAC;AACH,CAAC"}},
    {"offset": {"line": 947, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/_esm/actions/wallet/getCallsStatus.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/actions/wallet/getCallsStatus.ts"],"sourcesContent":["import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { ExtractCapabilities } from '../../types/capabilities.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { WalletGetCallsStatusReturnType } from '../../types/eip1193.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { RpcTransactionReceipt } from '../../types/rpc.js'\nimport type { Prettify } from '../../types/utils.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { sliceHex } from '../../utils/data/slice.js'\nimport { trim } from '../../utils/data/trim.js'\nimport { hexToBigInt, hexToNumber } from '../../utils/encoding/fromHex.js'\nimport { receiptStatuses } from '../../utils/formatters/transactionReceipt.js'\nimport {\n  fallbackMagicIdentifier,\n  fallbackTransactionErrorMagicIdentifier,\n} from './sendCalls.js'\n\nexport type GetCallsStatusParameters = { id: string }\n\nexport type GetCallsStatusReturnType = Prettify<\n  Omit<\n    WalletGetCallsStatusReturnType<\n      ExtractCapabilities<'getCallsStatus', 'ReturnType'>,\n      number,\n      bigint,\n      'success' | 'reverted'\n    >,\n    'status'\n  > & {\n    statusCode: number\n    status: 'pending' | 'success' | 'failure' | undefined\n  }\n>\n\nexport type GetCallsStatusErrorType = RequestErrorType | ErrorType\n\n/**\n * Returns the status of a call batch that was sent via `sendCalls`.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/getCallsStatus\n * - JSON-RPC Methods: [`wallet_getCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @returns Status of the calls. {@link GetCallsStatusReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getCallsStatus } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const { receipts, status } = await getCallsStatus(client, { id: '0xdeadbeef' })\n */\nexport async function getCallsStatus<\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: GetCallsStatusParameters,\n): Promise<GetCallsStatusReturnType> {\n  async function getStatus(id: Hex) {\n    const isTransactions = id.endsWith(fallbackMagicIdentifier.slice(2))\n    if (isTransactions) {\n      const chainId = trim(sliceHex(id, -64, -32))\n      const hashes = sliceHex(id, 0, -64)\n        .slice(2)\n        .match(/.{1,64}/g)\n\n      const receipts = await Promise.all(\n        hashes!.map((hash) =>\n          fallbackTransactionErrorMagicIdentifier.slice(2) !== hash\n            ? client.request(\n                {\n                  method: 'eth_getTransactionReceipt',\n                  params: [`0x${hash}`],\n                },\n                { dedupe: true },\n              )\n            : undefined,\n        ),\n      )\n\n      const status = (() => {\n        if (receipts.some((r) => r === null)) return 100 // pending\n        if (receipts.every((r) => r?.status === '0x1')) return 200 // success\n        if (receipts.every((r) => r?.status === '0x0')) return 500 // complete failure\n        return 600 // partial failure\n      })()\n\n      return {\n        atomic: false,\n        chainId: hexToNumber(chainId),\n        receipts: receipts.filter(Boolean) as RpcTransactionReceipt[],\n        status,\n        version: '2.0.0',\n      }\n    }\n    return client.request({\n      method: 'wallet_getCallsStatus',\n      params: [id],\n    })\n  }\n\n  const {\n    atomic = false,\n    chainId,\n    receipts,\n    version = '2.0.0',\n    ...response\n  } = await getStatus(parameters.id as Hex)\n  const [status, statusCode] = (() => {\n    const statusCode = response.status\n    if (statusCode >= 100 && statusCode < 200)\n      return ['pending', statusCode] as const\n    if (statusCode >= 200 && statusCode < 300)\n      return ['success', statusCode] as const\n    if (statusCode >= 300 && statusCode < 700)\n      return ['failure', statusCode] as const\n    // @ts-expect-error: for backwards compatibility\n    if (statusCode === 'CONFIRMED') return ['success', 200] as const\n    // @ts-expect-error: for backwards compatibility\n    if (statusCode === 'PENDING') return ['pending', 100] as const\n    return [undefined, statusCode]\n  })()\n  return {\n    ...response,\n    atomic,\n    // @ts-expect-error: for backwards compatibility\n    chainId: chainId ? hexToNumber(chainId) : undefined,\n    receipts:\n      receipts?.map((receipt) => ({\n        ...receipt,\n        blockNumber: hexToBigInt(receipt.blockNumber),\n        gasUsed: hexToBigInt(receipt.gasUsed),\n        status: receiptStatuses[receipt.status as '0x0' | '0x1'],\n      })) ?? [],\n    statusCode,\n    status,\n    version,\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1046, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/_esm/actions/wallet/getCapabilities.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/actions/wallet/getCapabilities.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type {\n  Capabilities,\n  ChainIdToCapabilities,\n  ExtractCapabilities,\n} from '../../types/capabilities.js'\nimport type { Prettify } from '../../types/utils.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\n\nexport type GetCapabilitiesParameters<\n  chainId extends number | undefined = undefined,\n> = {\n  account?: Account | Address | undefined\n  chainId?: chainId | number | undefined\n}\n\nexport type GetCapabilitiesReturnType<\n  chainId extends number | undefined = undefined,\n> = Prettify<\n  chainId extends number\n    ? ExtractCapabilities<'getCapabilities', 'ReturnType'>\n    : ChainIdToCapabilities<\n        Capabilities<ExtractCapabilities<'getCapabilities', 'ReturnType'>>,\n        number\n      >\n>\n\nexport type GetCapabilitiesErrorType = RequestErrorType | ErrorType\n\n/**\n * Extract capabilities that a connected wallet supports (e.g. paymasters, session keys, etc).\n *\n * - Docs: https://viem.sh/docs/actions/wallet/getCapabilities\n * - JSON-RPC Methods: [`wallet_getCapabilities`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @returns The wallet's capabilities. {@link GetCapabilitiesReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getCapabilities } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const capabilities = await getCapabilities(client)\n */\nexport async function getCapabilities<\n  chainId extends number | undefined = undefined,\n>(\n  client: Client<Transport>,\n  parameters: GetCapabilitiesParameters<chainId> = {},\n): Promise<GetCapabilitiesReturnType<chainId>> {\n  const { account = client.account, chainId } = parameters\n\n  const account_ = account ? parseAccount(account) : undefined\n\n  const params = chainId\n    ? ([account_?.address, [numberToHex(chainId)]] as const)\n    : ([account_?.address] as const)\n  const capabilities_raw = await client.request({\n    method: 'wallet_getCapabilities',\n    params,\n  })\n\n  const capabilities = {} as ChainIdToCapabilities<\n    ExtractCapabilities<'getCapabilities', 'ReturnType'>,\n    number\n  >\n  for (const [chainId, capabilities_] of Object.entries(capabilities_raw)) {\n    capabilities[Number(chainId)] = {}\n    for (let [key, value] of Object.entries(capabilities_)) {\n      if (key === 'addSubAccount') key = 'unstable_addSubAccount'\n      capabilities[Number(chainId)][key] = value\n    }\n  }\n  return (\n    typeof chainId === 'number' ? capabilities[chainId] : capabilities\n  ) as never\n}\n"],"names":[],"mappings":";;;;AAEA,OAAO,EAAE,YAAY,EAAE,MAAM,sCAAsC,CAAA;AAYnE,OAAO,EAAE,WAAW,EAAE,MAAM,+BAA+B,CAAA;;;AA0CpD,KAAK,UAAU,eAAe,CAGnC,MAAyB,EACzB,aAAiD,CAAA,CAAE;IAEnD,MAAM,EAAE,OAAO,GAAG,MAAM,CAAC,OAAO,EAAE,OAAO,EAAE,GAAG,UAAU,CAAA;IAExD,MAAM,QAAQ,GAAG,OAAO,CAAC,CAAC,KAAC,2OAAY,EAAC,OAAO,CAAC,CAAC,CAAC,CAAC,SAAS,CAAA;IAE5D,MAAM,MAAM,GAAG,OAAO,GACjB;QAAC,QAAQ,EAAE,OAAO;QAAE;gBAAC,mOAAW,EAAC,OAAO,CAAC;SAAC;KAAW,GACrD;QAAC,QAAQ,EAAE,OAAO;KAAW,CAAA;IAClC,MAAM,gBAAgB,GAAG,MAAM,MAAM,CAAC,OAAO,CAAC;QAC5C,MAAM,EAAE,wBAAwB;QAChC,MAAM;KACP,CAAC,CAAA;IAEF,MAAM,YAAY,GAAG,CAAA,CAGpB,CAAA;IACD,KAAK,MAAM,CAAC,OAAO,EAAE,aAAa,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,gBAAgB,CAAC,CAAE,CAAC;QACxE,YAAY,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,GAAG,CAAA,CAAE,CAAA;QAClC,KAAK,IAAI,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,aAAa,CAAC,CAAE,CAAC;YACvD,IAAI,GAAG,KAAK,eAAe,EAAE,GAAG,GAAG,wBAAwB,CAAA;YAC3D,YAAY,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,KAAK,CAAA;QAC5C,CAAC;IACH,CAAC;IACD,OAAO,AACL,OAAO,OAAO,KAAK,QAAQ,CAAC,CAAC,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,YAAY,CAC1D,CAAA;AACZ,CAAC"}},
    {"offset": {"line": 1083, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/_esm/actions/wallet/getPermissions.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/actions/wallet/getPermissions.ts"],"sourcesContent":["import type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { WalletPermission } from '../../types/eip1193.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type GetPermissionsReturnType = WalletPermission[]\n\nexport type GetPermissionsErrorType = RequestErrorType | ErrorType\n\n/**\n * Gets the wallets current permissions.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/getPermissions\n * - JSON-RPC Methods: [`wallet_getPermissions`](https://eips.ethereum.org/EIPS/eip-2255)\n *\n * @param client - Client to use\n * @returns The wallet permissions. {@link GetPermissionsReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getPermissions } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const permissions = await getPermissions(client)\n */\nexport async function getPermissions<\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n>(client: Client<Transport, chain, account>) {\n  const permissions = await client.request(\n    { method: 'wallet_getPermissions' },\n    { dedupe: true },\n  )\n  return permissions\n}\n"],"names":[],"mappings":"AAYA;;;;;;;;;;;;;;;;;;;GAmBG;;;;AACI,KAAK,UAAU,cAAc,CAGlC,MAAyC;IACzC,MAAM,WAAW,GAAG,MAAM,MAAM,CAAC,OAAO,CACtC;QAAE,MAAM,EAAE,uBAAuB;IAAA,CAAE,EACnC;QAAE,MAAM,EAAE,IAAI;IAAA,CAAE,CACjB,CAAA;IACD,OAAO,WAAW,CAAA;AACpB,CAAC"}},
    {"offset": {"line": 1118, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/_esm/actions/wallet/prepareAuthorization.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/actions/wallet/prepareAuthorization.ts"],"sourcesContent":["import type { Address } from 'abitype'\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  AccountNotFoundError,\n  type AccountNotFoundErrorType,\n} from '../../errors/account.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type {\n  Authorization,\n  AuthorizationRequest,\n} from '../../types/authorization.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { PartialBy } from '../../types/utils.js'\nimport { isAddressEqual } from '../../utils/address/isAddressEqual.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { getChainId } from '../public/getChainId.js'\nimport { getTransactionCount } from '../public/getTransactionCount.js'\n\nexport type PrepareAuthorizationParameters<\n  account extends Account | undefined = Account | undefined,\n> = GetAccountParameter<account> &\n  PartialBy<AuthorizationRequest, 'chainId' | 'nonce'> & {\n    /**\n     * Whether the EIP-7702 Transaction will be executed by the EOA (signing this Authorization) or another Account.\n     *\n     * By default, it will be assumed that the EIP-7702 Transaction will\n     * be executed by another Account.\n     */\n    executor?: 'self' | Account | Address | undefined\n  }\n\nexport type PrepareAuthorizationReturnType = Authorization\n\nexport type PrepareAuthorizationErrorType =\n  | ParseAccountErrorType\n  | RequestErrorType\n  | AccountNotFoundErrorType\n  | ErrorType\n\n/**\n * Prepares an [EIP-7702 Authorization](https://eips.ethereum.org/EIPS/eip-7702) object for signing.\n * This Action will fill the required fields of the Authorization object if they are not provided (e.g. `nonce` and `chainId`).\n *\n * With the prepared Authorization object, you can use [`signAuthorization`](https://viem.sh/docs/eip7702/signAuthorization) to sign over the Authorization object.\n *\n * @param client - Client to use\n * @param parameters - {@link PrepareAuthorizationParameters}\n * @returns The prepared Authorization object. {@link PrepareAuthorizationReturnType}\n *\n * @example\n * import { createClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { prepareAuthorization } from 'viem/experimental'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const authorization = await prepareAuthorization(client, {\n *   account: privateKeyToAccount('0x..'),\n *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n *\n * @example\n * // Account Hoisting\n * import { createClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { prepareAuthorization } from 'viem/experimental'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const authorization = await prepareAuthorization(client, {\n *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n */\nexport async function prepareAuthorization<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: PrepareAuthorizationParameters<account>,\n): Promise<PrepareAuthorizationReturnType> {\n  const { account: account_ = client.account, chainId, nonce } = parameters\n\n  if (!account_)\n    throw new AccountNotFoundError({\n      docsPath: '/docs/eip7702/prepareAuthorization',\n    })\n  const account = parseAccount(account_)\n\n  const executor = (() => {\n    if (!parameters.executor) return undefined\n    if (parameters.executor === 'self') return parameters.executor\n    return parseAccount(parameters.executor)\n  })()\n\n  const authorization = {\n    address: parameters.contractAddress ?? parameters.address,\n    chainId,\n    nonce,\n  } as Authorization\n\n  if (typeof authorization.chainId === 'undefined')\n    authorization.chainId =\n      client.chain?.id ??\n      (await getAction(client, getChainId, 'getChainId')({}))\n\n  if (typeof authorization.nonce === 'undefined') {\n    authorization.nonce = await getAction(\n      client,\n      getTransactionCount,\n      'getTransactionCount',\n    )({\n      address: account.address,\n      blockTag: 'pending',\n    })\n    if (\n      executor === 'self' ||\n      (executor?.address && isAddressEqual(executor.address, account.address))\n    )\n      authorization.nonce += 1\n  }\n\n  return authorization\n}\n"],"names":[],"mappings":";;;;AAEA,OAAO,EAEL,YAAY,GACb,MAAM,sCAAsC,CAAA;AAG7C,OAAO,EACL,oBAAoB,GAErB,MAAM,yBAAyB,CAAA;AAShC,OAAO,EAAE,cAAc,EAAE,MAAM,uCAAuC,CAAA;AAEtE,OAAO,EAAE,SAAS,EAAE,MAAM,0BAA0B,CAAA;AACpD,OAAO,EAAE,UAAU,EAAE,MAAM,yBAAyB,CAAA;AACpD,OAAO,EAAE,mBAAmB,EAAE,MAAM,kCAAkC,CAAA;;;;;;;AAgE/D,KAAK,UAAU,oBAAoB,CAIxC,MAAyC,EACzC,UAAmD;IAEnD,MAAM,EAAE,OAAO,EAAE,QAAQ,GAAG,MAAM,CAAC,OAAO,EAAE,OAAO,EAAE,KAAK,EAAE,GAAG,UAAU,CAAA;IAEzE,IAAI,CAAC,QAAQ,EACX,MAAM,IAAI,mOAAoB,CAAC;QAC7B,QAAQ,EAAE,oCAAoC;KAC/C,CAAC,CAAA;IACJ,MAAM,OAAO,OAAG,2OAAY,EAAC,QAAQ,CAAC,CAAA;IAEtC,MAAM,QAAQ,GAAG,CAAC,GAAG,EAAE;QACrB,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,OAAO,SAAS,CAAA;QAC1C,IAAI,UAAU,CAAC,QAAQ,KAAK,MAAM,EAAE,OAAO,UAAU,CAAC,QAAQ,CAAA;QAC9D,WAAO,2OAAY,EAAC,UAAU,CAAC,QAAQ,CAAC,CAAA;IAC1C,CAAC,CAAC,EAAE,CAAA;IAEJ,MAAM,aAAa,GAAG;QACpB,OAAO,EAAE,UAAU,CAAC,eAAe,IAAI,UAAU,CAAC,OAAO;QACzD,OAAO;QACP,KAAK;KACW,CAAA;IAElB,IAAI,OAAO,aAAa,CAAC,OAAO,KAAK,WAAW,EAC9C,aAAa,CAAC,OAAO,GACnB,MAAM,CAAC,KAAK,EAAE,EAAE,IACf,UAAM,yNAAS,EAAC,MAAM,EAAE,uOAAU,EAAE,YAAY,CAAC,CAAC,CAAA,CAAE,CAAC,CAAC,CAAA;IAE3D,IAAI,OAAO,aAAa,CAAC,KAAK,KAAK,WAAW,EAAE,CAAC;QAC/C,aAAa,CAAC,KAAK,GAAG,UAAM,yNAAS,EACnC,MAAM,EACN,yPAAmB,EACnB,qBAAqB,CACtB,CAAC;YACA,OAAO,EAAE,OAAO,CAAC,OAAO;YACxB,QAAQ,EAAE,SAAS;SACpB,CAAC,CAAA;QACF,IACE,QAAQ,KAAK,MAAM,IAClB,QAAQ,EAAE,OAAO,QAAI,8OAAc,EAAC,QAAQ,CAAC,OAAO,EAAE,OAAO,CAAC,OAAO,CAAC,CAAC,CAExE,aAAa,CAAC,KAAK,IAAI,CAAC,CAAA;IAC5B,CAAC;IAED,OAAO,aAAa,CAAA;AACtB,CAAC"}},
    {"offset": {"line": 1164, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/_esm/actions/wallet/requestAddresses.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/actions/wallet/requestAddresses.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport { getAddress } from '../../utils/address/getAddress.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type RequestAddressesReturnType = Address[]\n\nexport type RequestAddressesErrorType = RequestErrorType | ErrorType\n\n/**\n * Requests a list of accounts managed by a wallet.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/requestAddresses\n * - JSON-RPC Methods: [`eth_requestAccounts`](https://eips.ethereum.org/EIPS/eip-1102)\n *\n * Sends a request to the wallet, asking for permission to access the user's accounts. After the user accepts the request, it will return a list of accounts (addresses).\n *\n * This API can be useful for dapps that need to access the user's accounts in order to execute transactions or interact with smart contracts.\n *\n * @param client - Client to use\n * @returns List of accounts managed by a wallet {@link RequestAddressesReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { requestAddresses } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const accounts = await requestAddresses(client)\n */\nexport async function requestAddresses<\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n): Promise<RequestAddressesReturnType> {\n  const addresses = await client.request(\n    { method: 'eth_requestAccounts' },\n    { dedupe: true, retryCount: 0 },\n  )\n  return addresses.map((address) => getAddress(address))\n}\n"],"names":[],"mappings":";;;;AAOA,OAAO,EAAE,UAAU,EAAE,MAAM,mCAAmC,CAAA;;AA+BvD,KAAK,UAAU,gBAAgB,CAIpC,MAAyC;IAEzC,MAAM,SAAS,GAAG,MAAM,MAAM,CAAC,OAAO,CACpC;QAAE,MAAM,EAAE,qBAAqB;IAAA,CAAE,EACjC;QAAE,MAAM,EAAE,IAAI;QAAE,UAAU,EAAE,CAAC;IAAA,CAAE,CAChC,CAAA;IACD,OAAO,SAAS,CAAC,GAAG,CAAC,CAAC,OAAO,EAAE,EAAE,GAAC,sOAAU,EAAC,OAAO,CAAC,CAAC,CAAA;AACxD,CAAC"}},
    {"offset": {"line": 1183, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/_esm/actions/wallet/requestPermissions.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/actions/wallet/requestPermissions.ts"],"sourcesContent":["import type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { WalletPermission } from '../../types/eip1193.js'\nimport type { Prettify } from '../../types/utils.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type RequestPermissionsParameters = Prettify<\n  {\n    eth_accounts: Record<string, any>\n  } & {\n    [key: string]: Record<string, any>\n  }\n>\nexport type RequestPermissionsReturnType = WalletPermission[]\n\nexport type RequestPermissionsErrorType = RequestErrorType | ErrorType\n\n/**\n * Requests permissions for a wallet.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/requestPermissions\n * - JSON-RPC Methods: [`wallet_requestPermissions`](https://eips.ethereum.org/EIPS/eip-2255)\n *\n * @param client - Client to use\n * @param parameters - {@link RequestPermissionsParameters}\n * @returns The wallet permissions. {@link RequestPermissionsReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { requestPermissions } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const permissions = await requestPermissions(client, {\n *   eth_accounts: {}\n * })\n */\nexport async function requestPermissions<\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  permissions: RequestPermissionsParameters,\n) {\n  return client.request(\n    {\n      method: 'wallet_requestPermissions',\n      params: [permissions],\n    },\n    { retryCount: 0 },\n  )\n}\n"],"names":[],"mappings":"AAoBA;;;;;;;;;;;;;;;;;;;;;;GAsBG;;;;AACI,KAAK,UAAU,kBAAkB,CAItC,MAAyC,EACzC,WAAyC;IAEzC,OAAO,MAAM,CAAC,OAAO,CACnB;QACE,MAAM,EAAE,2BAA2B;QACnC,MAAM,EAAE;YAAC,WAAW;SAAC;KACtB,EACD;QAAE,UAAU,EAAE,CAAC;IAAA,CAAE,CAClB,CAAA;AACH,CAAC"}},
    {"offset": {"line": 1223, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/_esm/errors/calls.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/errors/calls.ts"],"sourcesContent":["import type { GetCallsStatusReturnType } from '../actions/wallet/getCallsStatus.js'\nimport { BaseError } from './base.js'\n\nexport type BundleFailedErrorType = BundleFailedError & {\n  name: 'BundleFailedError'\n}\nexport class BundleFailedError extends BaseError {\n  result: GetCallsStatusReturnType\n\n  constructor(result: GetCallsStatusReturnType) {\n    super(`Call bundle failed with status: ${result.statusCode}`, {\n      name: 'BundleFailedError',\n    })\n\n    this.result = result\n  }\n}\n"],"names":[],"mappings":";;;;AACA,OAAO,EAAE,SAAS,EAAE,MAAM,WAAW,CAAA;;AAK/B,MAAO,iBAAkB,SAAQ,qNAAS;IAG9C,YAAY,MAAgC,CAAA;QAC1C,KAAK,CAAC,CAAA,gCAAA,EAAmC,MAAM,CAAC,UAAU,EAAE,EAAE;YAC5D,IAAI,EAAE,mBAAmB;SAC1B,CAAC,CAAA;QALJ,OAAA,cAAA,CAAA,IAAA,EAAA,UAAA;;;;;WAAgC;QAO9B,IAAI,CAAC,MAAM,GAAG,MAAM,CAAA;IACtB,CAAC;CACF"}},
    {"offset": {"line": 1247, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/_esm/actions/wallet/waitForCallsStatus.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/actions/wallet/waitForCallsStatus.ts"],"sourcesContent":["import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { BaseError } from '../../errors/base.js'\nimport { BundleFailedError } from '../../errors/calls.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { type ObserveErrorType, observe } from '../../utils/observe.js'\nimport { type PollErrorType, poll } from '../../utils/poll.js'\nimport { withResolvers } from '../../utils/promise/withResolvers.js'\nimport {\n  type WithRetryParameters,\n  withRetry,\n} from '../../utils/promise/withRetry.js'\nimport { stringify } from '../../utils/stringify.js'\nimport {\n  type GetCallsStatusErrorType,\n  type GetCallsStatusReturnType,\n  getCallsStatus,\n} from './getCallsStatus.js'\n\nexport type WaitForCallsStatusParameters = {\n  /**\n   * The id of the call batch to wait for.\n   */\n  id: string\n  /**\n   * Polling frequency (in ms). Defaults to the client's pollingInterval config.\n   *\n   * @default client.pollingInterval\n   */\n  pollingInterval?: number | undefined\n  /**\n   * Number of times to retry if the call bundle failed.\n   * @default 4 (exponential backoff)\n   */\n  retryCount?: WithRetryParameters['retryCount'] | undefined\n  /**\n   * Time to wait (in ms) between retries.\n   * @default `({ count }) => ~~(1 << count) * 200` (exponential backoff)\n   */\n  retryDelay?: WithRetryParameters['delay'] | undefined\n  /**\n   * The status range to wait for.\n   *\n   * @default (status) => status >= 200\n   */\n  status?: ((parameters: GetCallsStatusReturnType) => boolean) | undefined\n  /**\n   * Whether to throw an error if the call bundle fails.\n   *\n   * @default false\n   */\n  throwOnFailure?: boolean | undefined\n  /**\n   * Optional timeout (in milliseconds) to wait before stopping polling.\n   *\n   * @default 60_000\n   */\n  timeout?: number | undefined\n}\n\nexport type WaitForCallsStatusReturnType = GetCallsStatusReturnType\n\nexport type WaitForCallsStatusErrorType =\n  | ObserveErrorType\n  | PollErrorType\n  | GetCallsStatusErrorType\n  | WaitForCallsStatusTimeoutError\n  | ErrorType\n\n/**\n * Waits for the status & receipts of a call bundle that was sent via `sendCalls`.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/waitForCallsStatus\n * - JSON-RPC Methods: [`wallet_getCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForCallsStatusParameters}\n * @returns Status & receipts of the call bundle. {@link WaitForCallsStatusReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { waitForCallsStatus } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n *\n * const { receipts, status } = await waitForCallsStatus(client, { id: '0xdeadbeef' })\n */\nexport async function waitForCallsStatus<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: WaitForCallsStatusParameters,\n): Promise<WaitForCallsStatusReturnType> {\n  const {\n    id,\n    pollingInterval = client.pollingInterval,\n    status = ({ statusCode }) => statusCode === 200 || statusCode >= 300,\n    retryCount = 4,\n    retryDelay = ({ count }) => ~~(1 << count) * 200, // exponential backoff\n    timeout = 60_000,\n    throwOnFailure = false,\n  } = parameters\n  const observerId = stringify(['waitForCallsStatus', client.uid, id])\n\n  const { promise, resolve, reject } =\n    withResolvers<WaitForCallsStatusReturnType>()\n\n  let timer: Timer | undefined\n\n  const unobserve = observe(observerId, { resolve, reject }, (emit) => {\n    const unpoll = poll(\n      async () => {\n        const done = (fn: () => void) => {\n          clearTimeout(timer)\n          unpoll()\n          fn()\n          unobserve()\n        }\n\n        try {\n          const result = await withRetry(\n            async () => {\n              const result = await getAction(\n                client,\n                getCallsStatus,\n                'getCallsStatus',\n              )({ id })\n              if (throwOnFailure && result.status === 'failure')\n                throw new BundleFailedError(result)\n              return result\n            },\n            {\n              retryCount,\n              delay: retryDelay,\n            },\n          )\n          if (!status(result)) return\n          done(() => emit.resolve(result))\n        } catch (error) {\n          done(() => emit.reject(error))\n        }\n      },\n      {\n        interval: pollingInterval,\n        emitOnBegin: true,\n      },\n    )\n\n    return unpoll\n  })\n\n  timer = timeout\n    ? setTimeout(() => {\n        unobserve()\n        clearTimeout(timer)\n        reject(new WaitForCallsStatusTimeoutError({ id }))\n      }, timeout)\n    : undefined\n\n  return await promise\n}\n\nexport type WaitForCallsStatusTimeoutErrorType =\n  WaitForCallsStatusTimeoutError & {\n    name: 'WaitForCallsStatusTimeoutError'\n  }\nexport class WaitForCallsStatusTimeoutError extends BaseError {\n  constructor({ id }: { id: string }) {\n    super(\n      `Timed out while waiting for call bundle with id \"${id}\" to be confirmed.`,\n      { name: 'WaitForCallsStatusTimeoutError' },\n    )\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1333, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/_esm/actions/wallet/sendCallsSync.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/actions/wallet/sendCallsSync.ts"],"sourcesContent":["import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { GetCallsStatusReturnType } from './getCallsStatus.js'\nimport {\n  type SendCallsErrorType,\n  type SendCallsParameters,\n  sendCalls,\n} from './sendCalls.js'\nimport {\n  type WaitForCallsStatusParameters,\n  waitForCallsStatus,\n} from './waitForCallsStatus.js'\n\nexport type SendCallsSyncParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  calls extends readonly unknown[] = readonly unknown[],\n> = SendCallsParameters<chain, account, chainOverride, calls> &\n  Pick<\n    WaitForCallsStatusParameters,\n    'pollingInterval' | 'status' | 'throwOnFailure'\n  > & {\n    /** Timeout (ms) to wait for calls to be included in a block. @default chain.blockTime * 3 */\n    timeout?: number | undefined\n  }\n\nexport type SendCallsSyncReturnType = GetCallsStatusReturnType\n\nexport type SendCallsSyncErrorType = SendCallsErrorType\n\n/**\n * Requests the connected wallet to send a batch of calls, and waits for the calls to be included in a block.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/sendCallsSync\n * - JSON-RPC Methods: [`wallet_sendCalls`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @returns Calls status. {@link SendCallsSyncReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { sendCalls } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const status = await sendCallsSync(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   calls: [\n *     {\n *       data: '0xdeadbeef',\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *     },\n *     {\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *       value: 69420n,\n *     },\n *   ],\n * })\n */\nexport async function sendCallsSync<\n  const calls extends readonly unknown[],\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: SendCallsSyncParameters<chain, account, chainOverride, calls>,\n): Promise<SendCallsSyncReturnType> {\n  const { chain = client.chain } = parameters\n  const timeout =\n    parameters.timeout ?? Math.max((chain?.blockTime ?? 0) * 3, 5_000)\n  const result = await sendCalls(client, parameters)\n  const status = await waitForCallsStatus(client, {\n    ...parameters,\n    id: result.id,\n    timeout,\n  })\n  return status\n}\n"],"names":[],"mappings":";;;;AAKA,OAAO,EAGL,SAAS,GACV,MAAM,gBAAgB,CAAA;AACvB,OAAO,EAEL,kBAAkB,GACnB,MAAM,yBAAyB,CAAA;;;AAoDzB,KAAK,UAAU,aAAa,CAMjC,MAAyC,EACzC,UAAyE;IAEzE,MAAM,EAAE,KAAK,GAAG,MAAM,CAAC,KAAK,EAAE,GAAG,UAAU,CAAA;IAC3C,MAAM,OAAO,GACX,UAAU,CAAC,OAAO,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,SAAS,IAAI,CAAC,CAAC,GAAG,CAAC,EAAE,KAAK,CAAC,CAAA;IACpE,MAAM,MAAM,GAAG,UAAM,qOAAS,EAAC,MAAM,EAAE,UAAU,CAAC,CAAA;IAClD,MAAM,MAAM,GAAG,UAAM,uPAAkB,EAAC,MAAM,EAAE;QAC9C,GAAG,UAAU;QACb,EAAE,EAAE,MAAM,CAAC,EAAE;QACb,OAAO;KACR,CAAC,CAAA;IACF,OAAO,MAAM,CAAA;AACf,CAAC"}},
    {"offset": {"line": 1356, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/_esm/actions/wallet/sendTransactionSync.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/actions/wallet/sendTransactionSync.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { SignTransactionErrorType } from '../../accounts/utils/signTransaction.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  AccountNotFoundError,\n  type AccountNotFoundErrorType,\n  AccountTypeNotSupportedError,\n  type AccountTypeNotSupportedErrorType,\n} from '../../errors/account.js'\nimport { BaseError } from '../../errors/base.js'\nimport {\n  TransactionReceiptRevertedError,\n  type TransactionReceiptRevertedErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../types/chain.js'\nimport type { GetTransactionRequestKzgParameter } from '../../types/kzg.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport type { UnionOmit } from '../../types/utils.js'\nimport {\n  type RecoverAuthorizationAddressErrorType,\n  recoverAuthorizationAddress,\n} from '../../utils/authorization/recoverAuthorizationAddress.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type AssertCurrentChainErrorType,\n  assertCurrentChain,\n} from '../../utils/chain/assertCurrentChain.js'\nimport {\n  type GetTransactionErrorReturnType,\n  getTransactionError,\n} from '../../utils/errors/getTransactionError.js'\nimport { extract } from '../../utils/formatters/extract.js'\nimport {\n  type FormattedTransactionRequest,\n  formatTransactionRequest,\n} from '../../utils/formatters/transactionRequest.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { LruMap } from '../../utils/lru.js'\nimport {\n  type AssertRequestErrorType,\n  type AssertRequestParameters,\n  assertRequest,\n} from '../../utils/transaction/assertRequest.js'\nimport { type GetChainIdErrorType, getChainId } from '../public/getChainId.js'\nimport {\n  type WaitForTransactionReceiptErrorType,\n  waitForTransactionReceipt,\n} from '../public/waitForTransactionReceipt.js'\nimport {\n  defaultParameters,\n  type PrepareTransactionRequestErrorType,\n  prepareTransactionRequest,\n} from './prepareTransactionRequest.js'\nimport {\n  type SendRawTransactionSyncErrorType,\n  type SendRawTransactionSyncReturnType,\n  sendRawTransactionSync,\n} from './sendRawTransactionSync.js'\n\nconst supportsWalletNamespace = new LruMap<boolean>(128)\n\nexport type SendTransactionSyncRequest<\n  chain extends Chain | undefined = Chain | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  ///\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = UnionOmit<FormattedTransactionRequest<_derivedChain>, 'from'> &\n  GetTransactionRequestKzgParameter\n\nexport type SendTransactionSyncParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  request extends SendTransactionSyncRequest<\n    chain,\n    chainOverride\n  > = SendTransactionSyncRequest<chain, chainOverride>,\n> = request &\n  GetAccountParameter<account, Account | Address, true, true> &\n  GetChainParameter<chain, chainOverride> &\n  GetTransactionRequestKzgParameter<request> & {\n    /** Polling interval (ms) to poll for the transaction receipt. @default client.pollingInterval */\n    pollingInterval?: number | undefined\n    /** Whether to throw an error if the transaction was detected as reverted. @default true */\n    throwOnReceiptRevert?: boolean | undefined\n    /** Timeout (ms) to wait for a response. @default Math.max(chain.blockTime * 3, 5_000) */\n    timeout?: number | undefined\n  }\n\nexport type SendTransactionSyncReturnType<\n  chain extends Chain | undefined = Chain | undefined,\n> = SendRawTransactionSyncReturnType<chain>\n\nexport type SendTransactionSyncErrorType =\n  | ParseAccountErrorType\n  | GetTransactionErrorReturnType<\n      | AccountNotFoundErrorType\n      | AccountTypeNotSupportedErrorType\n      | AssertCurrentChainErrorType\n      | AssertRequestErrorType\n      | GetChainIdErrorType\n      | PrepareTransactionRequestErrorType\n      | SendRawTransactionSyncErrorType\n      | RecoverAuthorizationAddressErrorType\n      | SignTransactionErrorType\n      | TransactionReceiptRevertedErrorType\n      | RequestErrorType\n    >\n  | WaitForTransactionReceiptErrorType\n  | ErrorType\n\n/**\n * Creates, signs, and sends a new transaction to the network synchronously.\n * Returns the transaction receipt.\n *\n * @param client - Client to use\n * @param parameters - {@link SendTransactionSyncParameters}\n * @returns The transaction receipt. {@link SendTransactionSyncReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { sendTransactionSync } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const receipt = await sendTransactionSync(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { sendTransactionSync } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const receipt = await sendTransactionSync(client, {\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n */\nexport async function sendTransactionSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  const request extends SendTransactionSyncRequest<chain, chainOverride>,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: SendTransactionSyncParameters<\n    chain,\n    account,\n    chainOverride,\n    request\n  >,\n): Promise<SendTransactionSyncReturnType<chain>> {\n  const {\n    account: account_ = client.account,\n    chain = client.chain,\n    accessList,\n    authorizationList,\n    blobs,\n    data,\n    gas,\n    gasPrice,\n    maxFeePerBlobGas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    pollingInterval,\n    throwOnReceiptRevert,\n    type,\n    value,\n    ...rest\n  } = parameters\n  const timeout =\n    parameters.timeout ?? Math.max((chain?.blockTime ?? 0) * 3, 5_000)\n\n  if (typeof account_ === 'undefined')\n    throw new AccountNotFoundError({\n      docsPath: '/docs/actions/wallet/sendTransactionSync',\n    })\n  const account = account_ ? parseAccount(account_) : null\n\n  try {\n    assertRequest(parameters as AssertRequestParameters)\n\n    const to = await (async () => {\n      // If `to` exists on the parameters, use that.\n      if (parameters.to) return parameters.to\n\n      // If `to` is null, we are sending a deployment transaction.\n      if (parameters.to === null) return undefined\n\n      // If no `to` exists, and we are sending a EIP-7702 transaction, use the\n      // address of the first authorization in the list.\n      if (authorizationList && authorizationList.length > 0)\n        return await recoverAuthorizationAddress({\n          authorization: authorizationList[0],\n        }).catch(() => {\n          throw new BaseError(\n            '`to` is required. Could not infer from `authorizationList`.',\n          )\n        })\n\n      // Otherwise, we are sending a deployment transaction.\n      return undefined\n    })()\n\n    if (account?.type === 'json-rpc' || account === null) {\n      let chainId: number | undefined\n      if (chain !== null) {\n        chainId = await getAction(client, getChainId, 'getChainId')({})\n        assertCurrentChain({\n          currentChainId: chainId,\n          chain,\n        })\n      }\n\n      const chainFormat = client.chain?.formatters?.transactionRequest?.format\n      const format = chainFormat || formatTransactionRequest\n\n      const request = format(\n        {\n          // Pick out extra data that might exist on the chain's transaction request type.\n          ...extract(rest, { format: chainFormat }),\n          accessList,\n          account,\n          authorizationList,\n          blobs,\n          chainId,\n          data,\n          gas,\n          gasPrice,\n          maxFeePerBlobGas,\n          maxFeePerGas,\n          maxPriorityFeePerGas,\n          nonce,\n          to,\n          type,\n          value,\n        } as TransactionRequest,\n        'sendTransaction',\n      )\n\n      const isWalletNamespaceSupported = supportsWalletNamespace.get(client.uid)\n      const method = isWalletNamespaceSupported\n        ? 'wallet_sendTransaction'\n        : 'eth_sendTransaction'\n\n      const hash = await (async () => {\n        try {\n          return await client.request(\n            {\n              method,\n              params: [request],\n            },\n            { retryCount: 0 },\n          )\n        } catch (e) {\n          if (isWalletNamespaceSupported === false) throw e\n\n          const error = e as BaseError\n          // If the transport does not support the method or input, attempt to use the\n          // `wallet_sendTransaction` method.\n          if (\n            error.name === 'InvalidInputRpcError' ||\n            error.name === 'InvalidParamsRpcError' ||\n            error.name === 'MethodNotFoundRpcError' ||\n            error.name === 'MethodNotSupportedRpcError'\n          ) {\n            return (await client\n              .request(\n                {\n                  method: 'wallet_sendTransaction',\n                  params: [request],\n                },\n                { retryCount: 0 },\n              )\n              .then((hash) => {\n                supportsWalletNamespace.set(client.uid, true)\n                return hash\n              })\n              .catch((e) => {\n                const walletNamespaceError = e as BaseError\n                if (\n                  walletNamespaceError.name === 'MethodNotFoundRpcError' ||\n                  walletNamespaceError.name === 'MethodNotSupportedRpcError'\n                ) {\n                  supportsWalletNamespace.set(client.uid, false)\n                  throw error\n                }\n\n                throw walletNamespaceError\n              })) as never\n          }\n\n          throw error\n        }\n      })()\n\n      const receipt = await getAction(\n        client,\n        waitForTransactionReceipt,\n        'waitForTransactionReceipt',\n      )({\n        checkReplacement: false,\n        hash,\n        pollingInterval,\n        timeout,\n      })\n      if (throwOnReceiptRevert && receipt.status === 'reverted')\n        throw new TransactionReceiptRevertedError({ receipt })\n      return receipt\n    }\n\n    if (account?.type === 'local') {\n      // Prepare the request for signing (assign appropriate fees, etc.)\n      const request = await getAction(\n        client,\n        prepareTransactionRequest,\n        'prepareTransactionRequest',\n      )({\n        account,\n        accessList,\n        authorizationList,\n        blobs,\n        chain,\n        data,\n        gas,\n        gasPrice,\n        maxFeePerBlobGas,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        nonce,\n        nonceManager: account.nonceManager,\n        parameters: [...defaultParameters, 'sidecars'],\n        type,\n        value,\n        ...rest,\n        to,\n      } as any)\n\n      const serializer = chain?.serializers?.transaction\n      const serializedTransaction = (await account.signTransaction(request, {\n        serializer,\n      })) as Hash\n      return (await getAction(\n        client,\n        sendRawTransactionSync,\n        'sendRawTransactionSync',\n      )({\n        serializedTransaction,\n        throwOnReceiptRevert,\n      })) as never\n    }\n\n    if (account?.type === 'smart')\n      throw new AccountTypeNotSupportedError({\n        metaMessages: [\n          'Consider using the `sendUserOperation` Action instead.',\n        ],\n        docsPath: '/docs/actions/bundler/sendUserOperation',\n        type: 'smart',\n      })\n\n    throw new AccountTypeNotSupportedError({\n      docsPath: '/docs/actions/wallet/sendTransactionSync',\n      type: (account as any)?.type,\n    })\n  } catch (err) {\n    if (err instanceof AccountTypeNotSupportedError) throw err\n    throw getTransactionError(err as BaseError, {\n      ...parameters,\n      account,\n      chain: parameters.chain || undefined,\n    })\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1558, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/_esm/actions/wallet/showCallsStatus.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/actions/wallet/showCallsStatus.ts"],"sourcesContent":["import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type ShowCallsStatusParameters = { id: string }\n\nexport type ShowCallsStatusReturnType = void\n\nexport type ShowCallsStatusErrorType = RequestErrorType | ErrorType\n\n/**\n * Requests for the wallet to show information about a call batch\n * that was sent via `sendCalls`.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/showCallsStatus\n * - JSON-RPC Methods: [`wallet_showCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @returns Status of the calls. {@link ShowCallsStatusReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { showCallsStatus } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * await showCallsStatus(client, { id: '0xdeadbeef' })\n */\nexport async function showCallsStatus<\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: ShowCallsStatusParameters,\n): Promise<ShowCallsStatusReturnType> {\n  const { id } = parameters\n  await client.request({\n    method: 'wallet_showCallsStatus',\n    params: [id],\n  })\n  return\n}\n"],"names":[],"mappings":"AAaA;;;;;;;;;;;;;;;;;;;;GAoBG;;;;AACI,KAAK,UAAU,eAAe,CAInC,MAAyC,EACzC,UAAqC;IAErC,MAAM,EAAE,EAAE,EAAE,GAAG,UAAU,CAAA;IACzB,MAAM,MAAM,CAAC,OAAO,CAAC;QACnB,MAAM,EAAE,wBAAwB;QAChC,MAAM,EAAE;YAAC,EAAE;SAAC;KACb,CAAC,CAAA;IACF,OAAM;AACR,CAAC"}},
    {"offset": {"line": 1596, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/_esm/actions/wallet/signAuthorization.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/actions/wallet/signAuthorization.ts"],"sourcesContent":["import type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type {\n  SignAuthorizationErrorType as SignAuthorizationErrorType_account,\n  SignAuthorizationReturnType as SignAuthorizationReturnType_account,\n} from '../../accounts/utils/signAuthorization.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  AccountNotFoundError,\n  type AccountNotFoundErrorType,\n  AccountTypeNotSupportedError,\n  type AccountTypeNotSupportedErrorType,\n} from '../../errors/account.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport {\n  type PrepareAuthorizationErrorType,\n  type PrepareAuthorizationParameters,\n  prepareAuthorization,\n} from './prepareAuthorization.js'\n\nexport type SignAuthorizationParameters<\n  account extends Account | undefined = Account | undefined,\n> = PrepareAuthorizationParameters<account>\n\nexport type SignAuthorizationReturnType = SignAuthorizationReturnType_account\n\nexport type SignAuthorizationErrorType =\n  | ParseAccountErrorType\n  | AccountNotFoundErrorType\n  | AccountTypeNotSupportedErrorType\n  | PrepareAuthorizationErrorType\n  | SignAuthorizationErrorType_account\n  | ErrorType\n\n/**\n * Signs an [EIP-7702 Authorization](https://eips.ethereum.org/EIPS/eip-7702) object.\n *\n * With the calculated signature, you can:\n * - use [`verifyAuthorization`](https://viem.sh/docs/eip7702/verifyAuthorization) to verify the signed Authorization object,\n * - use [`recoverAuthorizationAddress`](https://viem.sh/docs/eip7702/recoverAuthorizationAddress) to recover the signing address from the signed Authorization object.\n *\n * @param client - Client to use\n * @param parameters - {@link SignAuthorizationParameters}\n * @returns The signed Authorization object. {@link SignAuthorizationReturnType}\n *\n * @example\n * import { createClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { signAuthorization } from 'viem/experimental'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const signature = await signAuthorization(client, {\n *   account: privateKeyToAccount('0x..'),\n *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n *\n * @example\n * // Account Hoisting\n * import { createClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { signAuthorization } from 'viem/experimental'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const signature = await signAuthorization(client, {\n *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n */\nexport async function signAuthorization<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: SignAuthorizationParameters<account>,\n): Promise<SignAuthorizationReturnType> {\n  const { account: account_ = client.account } = parameters\n\n  if (!account_)\n    throw new AccountNotFoundError({\n      docsPath: '/docs/eip7702/signAuthorization',\n    })\n  const account = parseAccount(account_)\n\n  if (!account.signAuthorization)\n    throw new AccountTypeNotSupportedError({\n      docsPath: '/docs/eip7702/signAuthorization',\n      metaMessages: [\n        'The `signAuthorization` Action does not support JSON-RPC Accounts.',\n      ],\n      type: account.type,\n    })\n\n  const authorization = await prepareAuthorization(client, parameters)\n  return account.signAuthorization(authorization)\n}\n"],"names":[],"mappings":";;;;AACA,OAAO,EAEL,YAAY,GACb,MAAM,sCAAsC,CAAA;AAO7C,OAAO,EACL,oBAAoB,EAEpB,4BAA4B,GAE7B,MAAM,yBAAyB,CAAA;AAGhC,OAAO,EAGL,oBAAoB,GACrB,MAAM,2BAA2B,CAAA;;;;AA0D3B,KAAK,UAAU,iBAAiB,CAIrC,MAAyC,EACzC,UAAgD;IAEhD,MAAM,EAAE,OAAO,EAAE,QAAQ,GAAG,MAAM,CAAC,OAAO,EAAE,GAAG,UAAU,CAAA;IAEzD,IAAI,CAAC,QAAQ,EACX,MAAM,IAAI,mOAAoB,CAAC;QAC7B,QAAQ,EAAE,iCAAiC;KAC5C,CAAC,CAAA;IACJ,MAAM,OAAO,OAAG,2OAAY,EAAC,QAAQ,CAAC,CAAA;IAEtC,IAAI,CAAC,OAAO,CAAC,iBAAiB,EAC5B,MAAM,IAAI,2OAA4B,CAAC;QACrC,QAAQ,EAAE,iCAAiC;QAC3C,YAAY,EAAE;YACZ,oEAAoE;SACrE;QACD,IAAI,EAAE,OAAO,CAAC,IAAI;KACnB,CAAC,CAAA;IAEJ,MAAM,aAAa,GAAG,UAAM,2PAAoB,EAAC,MAAM,EAAE,UAAU,CAAC,CAAA;IACpE,OAAO,OAAO,CAAC,iBAAiB,CAAC,aAAa,CAAC,CAAA;AACjD,CAAC"}},
    {"offset": {"line": 1626, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/_esm/actions/wallet/signTransaction.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/actions/wallet/signTransaction.ts"],"sourcesContent":["import type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { SignTransactionErrorType as SignTransactionErrorType_account } from '../../accounts/utils/signTransaction.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { AccountNotFoundError } from '../../errors/account.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../types/chain.js'\nimport type { GetTransactionRequestKzgParameter } from '../../types/kzg.js'\nimport type { RpcTransactionRequest } from '../../types/rpc.js'\nimport type {\n  TransactionRequest,\n  TransactionSerializable,\n  TransactionSerialized,\n} from '../../types/transaction.js'\nimport type { UnionOmit } from '../../types/utils.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type AssertCurrentChainErrorType,\n  assertCurrentChain,\n} from '../../utils/chain/assertCurrentChain.js'\nimport type { NumberToHexErrorType } from '../../utils/encoding/toHex.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\nimport {\n  type FormattedTransactionRequest,\n  formatTransactionRequest,\n} from '../../utils/formatters/transactionRequest.js'\nimport { getAction } from '../../utils/getAction.js'\nimport {\n  type AssertRequestErrorType,\n  assertRequest,\n} from '../../utils/transaction/assertRequest.js'\nimport type { GetTransactionType } from '../../utils/transaction/getTransactionType.js'\nimport { type GetChainIdErrorType, getChainId } from '../public/getChainId.js'\n\nexport type SignTransactionRequest<\n  chain extends Chain | undefined = Chain | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  ///\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = UnionOmit<FormattedTransactionRequest<_derivedChain>, 'from'>\n\nexport type SignTransactionParameters<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  request extends SignTransactionRequest<\n    chain,\n    chainOverride\n  > = SignTransactionRequest<chain, chainOverride>,\n> = request &\n  GetAccountParameter<account> &\n  GetChainParameter<chain, chainOverride> &\n  GetTransactionRequestKzgParameter<request>\n\nexport type SignTransactionReturnType<\n  request extends SignTransactionRequest = SignTransactionRequest,\n> = TransactionSerialized<GetTransactionType<request>>\n\nexport type SignTransactionErrorType =\n  | ParseAccountErrorType\n  | AssertRequestErrorType\n  | GetChainIdErrorType\n  | AssertCurrentChainErrorType\n  | SignTransactionErrorType_account\n  | NumberToHexErrorType\n  | RequestErrorType\n  | ErrorType\n\n/**\n * Signs a transaction.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/signTransaction\n * - JSON-RPC Methods:\n *   - JSON-RPC Accounts: [`eth_signTransaction`](https://ethereum.github.io/execution-apis/api-documentation/)\n *   - Local Accounts: Signs locally. No JSON-RPC request.\n *\n * @param args - {@link SignTransactionParameters}\n * @returns The signed serialized transaction. {@link SignTransactionReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { signTransaction } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const signature = await signTransaction(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: 1n,\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { signTransaction } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const signature = await signTransaction(client, {\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: 1n,\n * })\n */\nexport async function signTransaction<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  chainOverride extends Chain | undefined = undefined,\n  const request extends SignTransactionRequest<\n    chain,\n    chainOverride\n  > = SignTransactionRequest<chain, chainOverride>,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: SignTransactionParameters<chain, account, chainOverride, request>,\n): Promise<SignTransactionReturnType<request>> {\n  const {\n    account: account_ = client.account,\n    chain = client.chain,\n    ...transaction\n  } = parameters\n\n  if (!account_)\n    throw new AccountNotFoundError({\n      docsPath: '/docs/actions/wallet/signTransaction',\n    })\n  const account = parseAccount(account_)\n\n  assertRequest({\n    account,\n    ...parameters,\n  })\n\n  const chainId = await getAction(client, getChainId, 'getChainId')({})\n  if (chain !== null)\n    assertCurrentChain({\n      currentChainId: chainId,\n      chain,\n    })\n\n  const formatters = chain?.formatters || client.chain?.formatters\n  const format =\n    formatters?.transactionRequest?.format || formatTransactionRequest\n\n  if (account.signTransaction)\n    return account.signTransaction(\n      {\n        ...transaction,\n        chainId,\n      } as TransactionSerializable,\n      { serializer: client.chain?.serializers?.transaction },\n    ) as Promise<SignTransactionReturnType<request>>\n\n  return await client.request(\n    {\n      method: 'eth_signTransaction',\n      params: [\n        {\n          ...format(\n            {\n              ...transaction,\n              account,\n            } as unknown as TransactionRequest,\n            'signTransaction',\n          ),\n          chainId: numberToHex(chainId),\n          from: account.address,\n        } as unknown as RpcTransactionRequest,\n      ],\n    },\n    { retryCount: 0 },\n  )\n}\n"],"names":[],"mappings":";;;;AACA,OAAO,EAEL,YAAY,GACb,MAAM,sCAAsC,CAAA;AAI7C,OAAO,EAAE,oBAAoB,EAAE,MAAM,yBAAyB,CAAA;AAiB9D,OAAO,EAEL,kBAAkB,GACnB,MAAM,yCAAyC,CAAA;AAEhD,OAAO,EAAE,WAAW,EAAE,MAAM,+BAA+B,CAAA;AAC3D,OAAO,EAEL,wBAAwB,GACzB,MAAM,8CAA8C,CAAA;AACrD,OAAO,EAAE,SAAS,EAAE,MAAM,0BAA0B,CAAA;AACpD,OAAO,EAEL,aAAa,GACd,MAAM,0CAA0C,CAAA;AAEjD,OAAO,EAA4B,UAAU,EAAE,MAAM,yBAAyB,CAAA;;;;;;;;;AA+EvE,KAAK,UAAU,eAAe,CASnC,MAAyC,EACzC,UAA6E;IAE7E,MAAM,EACJ,OAAO,EAAE,QAAQ,GAAG,MAAM,CAAC,OAAO,EAClC,KAAK,GAAG,MAAM,CAAC,KAAK,EACpB,GAAG,WAAW,EACf,GAAG,UAAU,CAAA;IAEd,IAAI,CAAC,QAAQ,EACX,MAAM,IAAI,mOAAoB,CAAC;QAC7B,QAAQ,EAAE,sCAAsC;KACjD,CAAC,CAAA;IACJ,MAAM,OAAO,OAAG,2OAAY,EAAC,QAAQ,CAAC,CAAA;QAEtC,gPAAa,EAAC;QACZ,OAAO;QACP,GAAG,UAAU;KACd,CAAC,CAAA;IAEF,MAAM,OAAO,GAAG,UAAM,yNAAS,EAAC,MAAM,EAAE,uOAAU,EAAE,YAAY,CAAC,CAAC,CAAA,CAAE,CAAC,CAAA;IACrE,IAAI,KAAK,KAAK,IAAI,MAChB,oPAAkB,EAAC;QACjB,cAAc,EAAE,OAAO;QACvB,KAAK;KACN,CAAC,CAAA;IAEJ,MAAM,UAAU,GAAG,KAAK,EAAE,UAAU,IAAI,MAAM,CAAC,KAAK,EAAE,UAAU,CAAA;IAChE,MAAM,MAAM,GACV,UAAU,EAAE,kBAAkB,EAAE,MAAM,IAAI,+PAAwB,CAAA;IAEpE,IAAI,OAAO,CAAC,eAAe,EACzB,OAAO,OAAO,CAAC,eAAe,CAC5B;QACE,GAAG,WAAW;QACd,OAAO;KACmB,EAC5B;QAAE,UAAU,EAAE,MAAM,CAAC,KAAK,EAAE,WAAW,EAAE,WAAW;IAAA,CAAE,CACR,CAAA;IAElD,OAAO,MAAM,MAAM,CAAC,OAAO,CACzB;QACE,MAAM,EAAE,qBAAqB;QAC7B,MAAM,EAAE;YACN;gBACE,GAAG,MAAM,CACP;oBACE,GAAG,WAAW;oBACd,OAAO;iBACyB,EAClC,iBAAiB,CAClB;gBACD,OAAO,MAAE,mOAAW,EAAC,OAAO,CAAC;gBAC7B,IAAI,EAAE,OAAO,CAAC,OAAO;aACc;SACtC;KACF,EACD;QAAE,UAAU,EAAE,CAAC;IAAA,CAAE,CAClB,CAAA;AACH,CAAC"}},
    {"offset": {"line": 1689, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/_esm/actions/wallet/signTypedData.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/actions/wallet/signTypedData.ts"],"sourcesContent":["import type { TypedData } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { SignTypedDataErrorType as SignTypedDataErrorType_account } from '../../accounts/utils/signTypedData.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  AccountNotFoundError,\n  type AccountNotFoundErrorType,\n} from '../../errors/account.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { TypedDataDefinition } from '../../types/typedData.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport type { IsHexErrorType } from '../../utils/data/isHex.js'\nimport type { StringifyErrorType } from '../../utils/stringify.js'\nimport {\n  type GetTypesForEIP712DomainErrorType,\n  getTypesForEIP712Domain,\n  type SerializeTypedDataErrorType,\n  serializeTypedData,\n  type ValidateTypedDataErrorType,\n  validateTypedData,\n} from '../../utils/typedData.js'\n\nexport type SignTypedDataParameters<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n  account extends Account | undefined = undefined,\n  ///\n  primaryTypes = typedData extends TypedData ? keyof typedData : string,\n> = TypedDataDefinition<typedData, primaryType, primaryTypes> &\n  GetAccountParameter<account>\n\nexport type SignTypedDataReturnType = Hex\n\nexport type SignTypedDataErrorType =\n  | AccountNotFoundErrorType\n  | ParseAccountErrorType\n  | GetTypesForEIP712DomainErrorType\n  | ValidateTypedDataErrorType\n  | StringifyErrorType\n  | SignTypedDataErrorType_account\n  | IsHexErrorType\n  | RequestErrorType\n  | SerializeTypedDataErrorType\n  | ErrorType\n\n/**\n * Signs typed data and calculates an Ethereum-specific signature in [https://eips.ethereum.org/EIPS/eip-712](https://eips.ethereum.org/EIPS/eip-712): `sign(keccak256(\"\\x19\\x01\" ‖ domainSeparator ‖ hashStruct(message)))`\n *\n * - Docs: https://viem.sh/docs/actions/wallet/signTypedData\n * - JSON-RPC Methods:\n *   - JSON-RPC Accounts: [`eth_signTypedData_v4`](https://docs.metamask.io/guide/signing-data#signtypeddata-v4)\n *   - Local Accounts: Signs locally. No JSON-RPC request.\n *\n * @param client - Client to use\n * @param parameters - {@link SignTypedDataParameters}\n * @returns The signed data. {@link SignTypedDataReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { signTypedData } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const signature = await signTypedData(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { signTypedData } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const signature = await signTypedData(client, {\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n */\nexport async function signTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: SignTypedDataParameters<typedData, primaryType, account>,\n): Promise<SignTypedDataReturnType> {\n  const {\n    account: account_ = client.account,\n    domain,\n    message,\n    primaryType,\n  } = parameters as unknown as SignTypedDataParameters\n\n  if (!account_)\n    throw new AccountNotFoundError({\n      docsPath: '/docs/actions/wallet/signTypedData',\n    })\n  const account = parseAccount(account_)\n\n  const types = {\n    EIP712Domain: getTypesForEIP712Domain({ domain }),\n    ...parameters.types,\n  }\n\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  validateTypedData({ domain, message, primaryType, types })\n\n  if (account.signTypedData)\n    return account.signTypedData({ domain, message, primaryType, types })\n\n  const typedData = serializeTypedData({ domain, message, primaryType, types })\n  return client.request(\n    {\n      method: 'eth_signTypedData_v4',\n      params: [account.address, typedData],\n    },\n    { retryCount: 0 },\n  )\n}\n"],"names":[],"mappings":";;;;AAGA,OAAO,EAEL,YAAY,GACb,MAAM,sCAAsC,CAAA;AAI7C,OAAO,EACL,oBAAoB,GAErB,MAAM,yBAAyB,CAAA;AAShC,OAAO,EAEL,uBAAuB,EAEvB,kBAAkB,EAElB,iBAAiB,GAClB,MAAM,0BAA0B,CAAA;;;;AA2H1B,KAAK,UAAU,aAAa,CAMjC,MAAyC,EACzC,UAAoE;IAEpE,MAAM,EACJ,OAAO,EAAE,QAAQ,GAAG,MAAM,CAAC,OAAO,EAClC,MAAM,EACN,OAAO,EACP,WAAW,EACZ,GAAG,UAAgD,CAAA;IAEpD,IAAI,CAAC,QAAQ,EACX,MAAM,IAAI,mOAAoB,CAAC;QAC7B,QAAQ,EAAE,oCAAoC;KAC/C,CAAC,CAAA;IACJ,MAAM,OAAO,OAAG,2OAAY,EAAC,QAAQ,CAAC,CAAA;IAEtC,MAAM,KAAK,GAAG;QACZ,YAAY,MAAE,uOAAuB,EAAC;YAAE,MAAM;QAAA,CAAE,CAAC;QACjD,GAAG,UAAU,CAAC,KAAK;KACpB,CAAA;IAED,uFAAuF;IACvF,qDAAqD;QACrD,iOAAiB,EAAC;QAAE,MAAM;QAAE,OAAO;QAAE,WAAW;QAAE,KAAK;IAAA,CAAE,CAAC,CAAA;IAE1D,IAAI,OAAO,CAAC,aAAa,EACvB,OAAO,OAAO,CAAC,aAAa,CAAC;QAAE,MAAM;QAAE,OAAO;QAAE,WAAW;QAAE,KAAK;IAAA,CAAE,CAAC,CAAA;IAEvE,MAAM,SAAS,OAAG,kOAAkB,EAAC;QAAE,MAAM;QAAE,OAAO;QAAE,WAAW;QAAE,KAAK;IAAA,CAAE,CAAC,CAAA;IAC7E,OAAO,MAAM,CAAC,OAAO,CACnB;QACE,MAAM,EAAE,sBAAsB;QAC9B,MAAM,EAAE;YAAC,OAAO,CAAC,OAAO;YAAE,SAAS;SAAC;KACrC,EACD;QAAE,UAAU,EAAE,CAAC;IAAA,CAAE,CAClB,CAAA;AACH,CAAC"}},
    {"offset": {"line": 1745, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/_esm/actions/wallet/switchChain.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/actions/wallet/switchChain.ts"],"sourcesContent":["import type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\n\nexport type SwitchChainParameters = {\n  /** ID of Chain to switch to */\n  id: Chain['id']\n}\n\nexport type SwitchChainErrorType =\n  | NumberToHexErrorType\n  | RequestErrorType\n  | ErrorType\n\n/**\n * Switch the target chain in a wallet.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/switchChain\n * - JSON-RPC Methods: [`wallet_switchEthereumChain`](https://eips.ethereum.org/EIPS/eip-3326)\n *\n * @param client - Client to use\n * @param parameters - {@link SwitchChainParameters}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet, optimism } from 'viem/chains'\n * import { switchChain } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * await switchChain(client, { id: optimism.id })\n */\nexport async function switchChain<\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n>(client: Client<Transport, chain, account>, { id }: SwitchChainParameters) {\n  await client.request(\n    {\n      method: 'wallet_switchEthereumChain',\n      params: [\n        {\n          chainId: numberToHex(id),\n        },\n      ],\n    },\n    { retryCount: 0 },\n  )\n}\n"],"names":[],"mappings":";;;;AAMA,OAAO,EAEL,WAAW,GACZ,MAAM,+BAA+B,CAAA;;AAgC/B,KAAK,UAAU,WAAW,CAG/B,MAAyC,EAAE,EAAE,EAAE,EAAyB;IACxE,MAAM,MAAM,CAAC,OAAO,CAClB;QACE,MAAM,EAAE,4BAA4B;QACpC,MAAM,EAAE;YACN;gBACE,OAAO,MAAE,mOAAW,EAAC,EAAE,CAAC;aACzB;SACF;KACF,EACD;QAAE,UAAU,EAAE,CAAC;IAAA,CAAE,CAClB,CAAA;AACH,CAAC"}},
    {"offset": {"line": 1767, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/_esm/actions/wallet/watchAsset.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/actions/wallet/watchAsset.ts"],"sourcesContent":["import type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { WatchAssetParams } from '../../types/eip1193.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type WatchAssetParameters = WatchAssetParams\nexport type WatchAssetReturnType = boolean\nexport type WatchAssetErrorType = RequestErrorType | ErrorType\n\n/**\n * Adds an EVM chain to the wallet.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/watchAsset\n * - JSON-RPC Methods: [`eth_switchEthereumChain`](https://eips.ethereum.org/EIPS/eip-747)\n *\n * @param client - Client to use\n * @param parameters - {@link WatchAssetParameters}\n * @returns Boolean indicating if the token was successfully added. {@link WatchAssetReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { watchAsset } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const success = await watchAsset(client, {\n *   type: 'ERC20',\n *   options: {\n *     address: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',\n *     decimals: 18,\n *     symbol: 'WETH',\n *   },\n * })\n */\nexport async function watchAsset<\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  params: WatchAssetParameters,\n): Promise<WatchAssetReturnType> {\n  const added = await client.request(\n    {\n      method: 'wallet_watchAsset',\n      params,\n    },\n    { retryCount: 0 },\n  )\n  return added\n}\n"],"names":[],"mappings":"AAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;GA2BG;;;;AACI,KAAK,UAAU,UAAU,CAI9B,MAAyC,EACzC,MAA4B;IAE5B,MAAM,KAAK,GAAG,MAAM,MAAM,CAAC,OAAO,CAChC;QACE,MAAM,EAAE,mBAAmB;QAC3B,MAAM;KACP,EACD;QAAE,UAAU,EAAE,CAAC;IAAA,CAAE,CAClB,CAAA;IACD,OAAO,KAAK,CAAA;AACd,CAAC"}},
    {"offset": {"line": 1811, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/_esm/actions/wallet/writeContractSync.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/actions/wallet/writeContractSync.ts"],"sourcesContent":["import type { Abi } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n} from '../../types/contract.js'\nimport {\n  type SendTransactionSyncParameters,\n  type SendTransactionSyncReturnType,\n  sendTransactionSync,\n} from './sendTransactionSync.js'\nimport { type WriteContractParameters, writeContract } from './writeContract.js'\n\nexport type { WriteContractErrorType as WriteContractSyncErrorType } from './writeContract.js'\n\nexport type WriteContractSyncParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'nonpayable' | 'payable'\n  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n> = WriteContractParameters<\n  abi,\n  functionName,\n  args,\n  chain,\n  account,\n  chainOverride\n> &\n  Pick<\n    SendTransactionSyncParameters<chain>,\n    'pollingInterval' | 'throwOnReceiptRevert' | 'timeout'\n  >\n\nexport type WriteContractSyncReturnType<\n  chain extends Chain | undefined = Chain | undefined,\n> = SendTransactionSyncReturnType<chain>\n\n/**\n * Executes a write function on a contract synchronously.\n * Returns the transaction receipt.\n *\n * - Docs: https://viem.sh/docs/contract/writeContractSync\n *\n * A \"write\" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, and hence a [Transaction](https://viem.sh/docs/glossary/terms) is needed to be broadcast in order to change the state.\n *\n * Internally, uses a [Wallet Client](https://viem.sh/docs/clients/wallet) to call the [`sendTransaction` action](https://viem.sh/docs/actions/wallet/sendTransaction) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n *\n * __Warning: The `write` internally sends a transaction – it does not validate if the contract write will succeed (the contract may throw an error). It is highly recommended to [simulate the contract write with `contract.simulate`](https://viem.sh/docs/contract/writeContract#usage) before you execute it.__\n *\n * @param client - Client to use\n * @param parameters - {@link WriteContractParameters}\n * @returns A [Transaction Hash](https://viem.sh/docs/glossary/terms#hash). {@link WriteContractReturnType}\n *\n * @example\n * import { createWalletClient, custom, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { writeContract } from 'viem/contract'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const receipt = await writeContractSync(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n *   functionName: 'mint',\n *   args: [69420],\n * })\n */\nexport async function writeContractSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  chainOverride extends Chain | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: WriteContractSyncParameters<\n    abi,\n    functionName,\n    args,\n    chain,\n    account,\n    chainOverride\n  >,\n): Promise<WriteContractSyncReturnType<chain>> {\n  return writeContract.internal(\n    client,\n    sendTransactionSync,\n    'sendTransactionSync',\n    parameters as never,\n  ) as never\n}\n"],"names":[],"mappings":";;;;AAUA,OAAO,EAGL,mBAAmB,GACpB,MAAM,0BAA0B,CAAA;AACjC,OAAO,EAAgC,aAAa,EAAE,MAAM,oBAAoB,CAAA;;;AAmEzE,KAAK,UAAU,iBAAiB,CAYrC,MAAyC,EACzC,UAOC;IAED,OAAO,6OAAa,CAAC,QAAQ,CAC3B,MAAM,EACN,yPAAmB,EACnB,qBAAqB,EACrB,UAAmB,CACX,CAAA;AACZ,CAAC"}},
    {"offset": {"line": 1826, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/_esm/clients/decorators/wallet.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/viem/clients/decorators/wallet.ts"],"sourcesContent":["import type { Abi, Address, TypedData } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type GetChainIdReturnType,\n  getChainId,\n} from '../../actions/public/getChainId.js'\nimport {\n  type AddChainParameters,\n  addChain,\n} from '../../actions/wallet/addChain.js'\nimport {\n  type DeployContractParameters,\n  type DeployContractReturnType,\n  deployContract,\n} from '../../actions/wallet/deployContract.js'\nimport {\n  type GetAddressesReturnType,\n  getAddresses,\n} from '../../actions/wallet/getAddresses.js'\nimport {\n  type GetCallsStatusParameters,\n  type GetCallsStatusReturnType,\n  getCallsStatus,\n} from '../../actions/wallet/getCallsStatus.js'\nimport {\n  type GetCapabilitiesParameters,\n  type GetCapabilitiesReturnType,\n  getCapabilities,\n} from '../../actions/wallet/getCapabilities.js'\nimport {\n  type GetPermissionsReturnType,\n  getPermissions,\n} from '../../actions/wallet/getPermissions.js'\nimport {\n  type PrepareAuthorizationParameters,\n  type PrepareAuthorizationReturnType,\n  prepareAuthorization,\n} from '../../actions/wallet/prepareAuthorization.js'\nimport {\n  type PrepareTransactionRequestParameters,\n  type PrepareTransactionRequestRequest,\n  type PrepareTransactionRequestReturnType,\n  prepareTransactionRequest,\n} from '../../actions/wallet/prepareTransactionRequest.js'\nimport {\n  type RequestAddressesReturnType,\n  requestAddresses,\n} from '../../actions/wallet/requestAddresses.js'\nimport {\n  type RequestPermissionsParameters,\n  type RequestPermissionsReturnType,\n  requestPermissions,\n} from '../../actions/wallet/requestPermissions.js'\nimport {\n  type SendCallsParameters,\n  type SendCallsReturnType,\n  sendCalls,\n} from '../../actions/wallet/sendCalls.js'\nimport {\n  type SendCallsSyncParameters,\n  type SendCallsSyncReturnType,\n  sendCallsSync,\n} from '../../actions/wallet/sendCallsSync.js'\nimport {\n  type SendRawTransactionParameters,\n  type SendRawTransactionReturnType,\n  sendRawTransaction,\n} from '../../actions/wallet/sendRawTransaction.js'\nimport {\n  type SendRawTransactionSyncParameters,\n  type SendRawTransactionSyncReturnType,\n  sendRawTransactionSync,\n} from '../../actions/wallet/sendRawTransactionSync.js'\nimport {\n  type SendTransactionParameters,\n  type SendTransactionRequest,\n  type SendTransactionReturnType,\n  sendTransaction,\n} from '../../actions/wallet/sendTransaction.js'\nimport {\n  type SendTransactionSyncParameters,\n  type SendTransactionSyncRequest,\n  type SendTransactionSyncReturnType,\n  sendTransactionSync,\n} from '../../actions/wallet/sendTransactionSync.js'\nimport {\n  type ShowCallsStatusParameters,\n  type ShowCallsStatusReturnType,\n  showCallsStatus,\n} from '../../actions/wallet/showCallsStatus.js'\nimport {\n  type SignAuthorizationParameters,\n  type SignAuthorizationReturnType,\n  signAuthorization,\n} from '../../actions/wallet/signAuthorization.js'\nimport {\n  type SignMessageParameters,\n  type SignMessageReturnType,\n  signMessage,\n} from '../../actions/wallet/signMessage.js'\nimport {\n  type SignTransactionParameters,\n  type SignTransactionRequest,\n  type SignTransactionReturnType,\n  signTransaction,\n} from '../../actions/wallet/signTransaction.js'\nimport {\n  type SignTypedDataParameters,\n  type SignTypedDataReturnType,\n  signTypedData,\n} from '../../actions/wallet/signTypedData.js'\nimport {\n  type SwitchChainParameters,\n  switchChain,\n} from '../../actions/wallet/switchChain.js'\nimport {\n  type WaitForCallsStatusParameters,\n  type WaitForCallsStatusReturnType,\n  waitForCallsStatus,\n} from '../../actions/wallet/waitForCallsStatus.js'\nimport {\n  type WatchAssetParameters,\n  type WatchAssetReturnType,\n  watchAsset,\n} from '../../actions/wallet/watchAsset.js'\nimport {\n  type WriteContractParameters,\n  type WriteContractReturnType,\n  writeContract,\n} from '../../actions/wallet/writeContract.js'\nimport {\n  type WriteContractSyncParameters,\n  type WriteContractSyncReturnType,\n  writeContractSync,\n} from '../../actions/wallet/writeContractSync.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n} from '../../types/contract.js'\nimport type { Client } from '../createClient.js'\nimport type { Transport } from '../transports/createTransport.js'\n\nexport type WalletActions<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n> = {\n  /**\n   * Adds an EVM chain to the wallet.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/addChain\n   * - JSON-RPC Methods: [`eth_addEthereumChain`](https://eips.ethereum.org/EIPS/eip-3085)\n   *\n   * @param args - {@link AddChainParameters}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { optimism } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   transport: custom(window.ethereum),\n   * })\n   * await client.addChain({ chain: optimism })\n   */\n  addChain: (args: AddChainParameters) => Promise<void>\n  /**\n   * Deploys a contract to the network, given bytecode and constructor arguments.\n   *\n   * - Docs: https://viem.sh/docs/contract/deployContract\n   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_deploying-contracts\n   *\n   * @param args - {@link DeployContractParameters}\n   * @returns The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link DeployContractReturnType}\n   *\n   * @example\n   * import { createWalletClient, http } from 'viem'\n   * import { privateKeyToAccount } from 'viem/accounts'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   account: privateKeyToAccount('0x…'),\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const hash = await client.deployContract({\n   *   abi: [],\n   *   account: '0x…,\n   *   bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',\n   * })\n   */\n  deployContract: <\n    const abi extends Abi | readonly unknown[],\n    chainOverride extends Chain | undefined,\n  >(\n    args: DeployContractParameters<abi, chain, account, chainOverride>,\n  ) => Promise<DeployContractReturnType>\n  /**\n   * Returns a list of account addresses owned by the wallet or client.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/getAddresses\n   * - JSON-RPC Methods: [`eth_accounts`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_accounts)\n   *\n   * @returns List of account addresses owned by the wallet or client. {@link GetAddressesReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const accounts = await client.getAddresses()\n   */\n  getAddresses: () => Promise<GetAddressesReturnType>\n  /**\n   * Returns the status of a call batch that was sent via `sendCalls`.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/getCallsStatus\n   * - JSON-RPC Methods: [`wallet_getCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)\n   *\n   * @param client - Client to use\n   * @returns Status of the calls. {@link GetCallsStatusReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   *\n   * const { receipts, status } = await client.getCallsStatus({ id: '0xdeadbeef' })\n   */\n  getCallsStatus: (\n    parameters: GetCallsStatusParameters,\n  ) => Promise<GetCallsStatusReturnType>\n  /**\n   * Extract capabilities that a connected wallet supports (e.g. paymasters, session keys, etc).\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/getCapabilities\n   * - JSON-RPC Methods: [`wallet_getCapabilities`](https://eips.ethereum.org/EIPS/eip-5792)\n   *\n   * @param client - Client to use\n   * @returns The wallet's capabilities. {@link GetCapabilitiesReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   *\n   * const capabilities = await client.getCapabilities({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   * })\n   */\n  getCapabilities: <chainId extends number | undefined>(\n    parameters?: GetCapabilitiesParameters<chainId>,\n  ) => Promise<GetCapabilitiesReturnType<chainId>>\n  /**\n   * Returns the chain ID associated with the current network.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getChainId\n   * - JSON-RPC Methods: [`eth_chainId`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid)\n   *\n   * @returns The current chain ID. {@link GetChainIdReturnType}\n   *\n   * @example\n   * import { createWalletClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const chainId = await client.getChainId()\n   * // 1\n   */\n  getChainId: () => Promise<GetChainIdReturnType>\n  /**\n   * Gets the wallets current permissions.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/getPermissions\n   * - JSON-RPC Methods: [`wallet_getPermissions`](https://eips.ethereum.org/EIPS/eip-2255)\n   *\n   * @returns The wallet permissions. {@link GetPermissionsReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const permissions = await client.getPermissions()\n   */\n  getPermissions: () => Promise<GetPermissionsReturnType>\n  /**\n   * Prepares an [EIP-7702 Authorization](https://eips.ethereum.org/EIPS/eip-7702) object for signing.\n   * This Action will fill the required fields of the Authorization object if they are not provided (e.g. `nonce` and `chainId`).\n   *\n   * With the prepared Authorization object, you can use [`signAuthorization`](https://viem.sh/docs/eip7702/signAuthorization) to sign over the Authorization object.\n   *\n   * @param client - Client to use\n   * @param parameters - {@link PrepareAuthorizationParameters}\n   * @returns The prepared Authorization object. {@link PrepareAuthorizationReturnType}\n   *\n   * @example\n   * import { createWalletClient, http } from 'viem'\n   * import { privateKeyToAccount } from 'viem/accounts'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const authorization = await client.prepareAuthorization({\n   *   account: privateKeyToAccount('0x..'),\n   *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   * })\n   *\n   * @example\n   * // Account Hoisting\n   * import { createWalletClient, http } from 'viem'\n   * import { privateKeyToAccount } from 'viem/accounts'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   account: privateKeyToAccount('0x…'),\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const authorization = await client.prepareAuthorization({\n   *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   * })\n   */\n  prepareAuthorization: (\n    parameters: PrepareAuthorizationParameters<account>,\n  ) => Promise<PrepareAuthorizationReturnType>\n  /**\n   * Prepares a transaction request for signing.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/prepareTransactionRequest\n   *\n   * @param args - {@link PrepareTransactionRequestParameters}\n   * @returns The transaction request. {@link PrepareTransactionRequestReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const request = await client.prepareTransactionRequest({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   to: '0x0000000000000000000000000000000000000000',\n   *   value: 1n,\n   * })\n   *\n   * @example\n   * // Account Hoisting\n   * import { createWalletClient, http } from 'viem'\n   * import { privateKeyToAccount } from 'viem/accounts'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   account: privateKeyToAccount('0x…'),\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const request = await client.prepareTransactionRequest({\n   *   to: '0x0000000000000000000000000000000000000000',\n   *   value: 1n,\n   * })\n   */\n  prepareTransactionRequest: <\n    const request extends PrepareTransactionRequestRequest<\n      chain,\n      chainOverride\n    >,\n    chainOverride extends Chain | undefined = undefined,\n    accountOverride extends Account | Address | undefined = undefined,\n  >(\n    args: PrepareTransactionRequestParameters<\n      chain,\n      account,\n      chainOverride,\n      accountOverride,\n      request\n    >,\n  ) => Promise<\n    PrepareTransactionRequestReturnType<\n      chain,\n      account,\n      chainOverride,\n      accountOverride,\n      request\n    >\n  >\n  /**\n   * Requests a list of accounts managed by a wallet.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/requestAddresses\n   * - JSON-RPC Methods: [`eth_requestAccounts`](https://eips.ethereum.org/EIPS/eip-1102)\n   *\n   * Sends a request to the wallet, asking for permission to access the user's accounts. After the user accepts the request, it will return a list of accounts (addresses).\n   *\n   * This API can be useful for dapps that need to access the user's accounts in order to execute transactions or interact with smart contracts.\n   *\n   * @returns List of accounts managed by a wallet {@link RequestAddressesReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const accounts = await client.requestAddresses()\n   */\n  requestAddresses: () => Promise<RequestAddressesReturnType>\n  /**\n   * Requests permissions for a wallet.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/requestPermissions\n   * - JSON-RPC Methods: [`wallet_requestPermissions`](https://eips.ethereum.org/EIPS/eip-2255)\n   *\n   * @param args - {@link RequestPermissionsParameters}\n   * @returns The wallet permissions. {@link RequestPermissionsReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const permissions = await client.requestPermissions({\n   *   eth_accounts: {}\n   * })\n   */\n  requestPermissions: (\n    args: RequestPermissionsParameters,\n  ) => Promise<RequestPermissionsReturnType>\n  /**\n   * Requests the connected wallet to send a batch of calls.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/sendCalls\n   * - JSON-RPC Methods: [`wallet_sendCalls`](https://eips.ethereum.org/EIPS/eip-5792)\n   *\n   * @param client - Client to use\n   * @returns Transaction identifier. {@link SendCallsReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   *\n   * const id = await client.sendCalls({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   calls: [\n   *     {\n   *       data: '0xdeadbeef',\n   *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *     },\n   *     {\n   *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *       value: 69420n,\n   *     },\n   *   ],\n   * })\n   */\n  sendCalls: <\n    const calls extends readonly unknown[],\n    chainOverride extends Chain | undefined = undefined,\n  >(\n    parameters: SendCallsParameters<chain, account, chainOverride, calls>,\n  ) => Promise<SendCallsReturnType>\n  /**\n   * Requests the connected wallet to send a batch of calls, and waits for the calls to be included in a block.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/sendCallsSync\n   * - JSON-RPC Methods: [`wallet_sendCalls`](https://eips.ethereum.org/EIPS/eip-5792)\n   *\n   * @param client - Client to use\n   * @returns Calls status. {@link SendCallsSyncReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   *\n   * const status = await client.sendCallsSync({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   calls: [\n   *     {\n   *       data: '0xdeadbeef',\n   *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *     },\n   *     {\n   *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *       value: 69420n,\n   *     },\n   *   ],\n   * })\n   */\n  sendCallsSync: <\n    const calls extends readonly unknown[],\n    chainOverride extends Chain | undefined = undefined,\n  >(\n    parameters: SendCallsSyncParameters<chain, account, chainOverride, calls>,\n  ) => Promise<SendCallsSyncReturnType>\n  /**\n   * Sends a **signed** transaction to the network\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/sendRawTransaction\n   * - JSON-RPC Method: [`eth_sendRawTransaction`](https://ethereum.github.io/execution-apis/api-documentation/)\n   *\n   * @param client - Client to use\n   * @param parameters - {@link SendRawTransactionParameters}\n   * @returns The transaction hash. {@link SendRawTransactionReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { sendRawTransaction } from 'viem/wallet'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   *\n   * const hash = await client.sendRawTransaction({\n   *   serializedTransaction: '0x02f850018203118080825208808080c080a04012522854168b27e5dc3d5839bab5e6b39e1a0ffd343901ce1622e3d64b48f1a04e00902ae0502c4728cbf12156290df99c3ed7de85b1dbfe20b5c36931733a33'\n   * })\n   */\n  sendRawTransaction: (\n    args: SendRawTransactionParameters,\n  ) => Promise<SendRawTransactionReturnType>\n  /**\n   * Sends a **signed** transaction to the network synchronously,\n   * and waits for the transaction to be included in a block.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/sendRawTransactionSync\n   * - JSON-RPC Method: [`eth_sendRawTransactionSync`](https://eips.ethereum.org/EIPS/eip-7966)\n   *\n   * @param client - Client to use\n   * @param parameters - {@link SendRawTransactionSyncParameters}\n   * @returns The transaction receipt. {@link SendRawTransactionSyncReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { sendRawTransactionSync } from 'viem/wallet'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   *\n   * const receipt = await client.sendRawTransactionSync({\n   *   serializedTransaction: '0x02f850018203118080825208808080c080a04012522854168b27e5dc3d5839bab5e6b39e1a0ffd343901ce1622e3d64b48f1a04e00902ae0502c4728cbf12156290df99c3ed7de85b1dbfe20b5c36931733a33'\n   * })\n   */\n  sendRawTransactionSync: (\n    args: SendRawTransactionSyncParameters,\n  ) => Promise<SendRawTransactionSyncReturnType<chain>>\n  /**\n   * Creates, signs, and sends a new transaction to the network.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/sendTransaction\n   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_sending-transactions\n   * - JSON-RPC Methods:\n   *   - JSON-RPC Accounts: [`eth_sendTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction)\n   *   - Local Accounts: [`eth_sendRawTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendrawtransaction)\n   *\n   * @param args - {@link SendTransactionParameters}\n   * @returns The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link SendTransactionReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const hash = await client.sendTransaction({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *   value: 1000000000000000000n,\n   * })\n   *\n   * @example\n   * // Account Hoisting\n   * import { createWalletClient, http } from 'viem'\n   * import { privateKeyToAccount } from 'viem/accounts'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   account: privateKeyToAccount('0x…'),\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const hash = await client.sendTransaction({\n   *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *   value: 1000000000000000000n,\n   * })\n   */\n  sendTransaction: <\n    const request extends SendTransactionRequest<chain, chainOverride>,\n    chainOverride extends Chain | undefined = undefined,\n  >(\n    args: SendTransactionParameters<chain, account, chainOverride, request>,\n  ) => Promise<SendTransactionReturnType>\n  /**\n   * Creates, signs, and sends a new transaction to the network synchronously.\n   * Returns the transaction receipt.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/sendTransactionSync\n   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_sending-transactions\n   * - JSON-RPC Methods:\n   *   - JSON-RPC Accounts: [`eth_sendTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction)\n   *   - Local Accounts: [`eth_sendRawTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendrawtransaction)\n   *\n   * @param args - {@link SendTransactionParameters}\n   * @returns The transaction receipt. {@link SendTransactionReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const receipt = await client.sendTransactionSync({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *   value: 1000000000000000000n,\n   * })\n   *\n   * @example\n   * // Account Hoisting\n   * import { createWalletClient, http } from 'viem'\n   * import { privateKeyToAccount } from 'viem/accounts'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   account: privateKeyToAccount('0x…'),\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const receipt = await client.sendTransactionSync({\n   *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *   value: 1000000000000000000n,\n   * })\n   */\n  sendTransactionSync: <\n    const request extends SendTransactionSyncRequest<chain, chainOverride>,\n    chainOverride extends Chain | undefined = undefined,\n  >(\n    args: SendTransactionSyncParameters<chain, account, chainOverride, request>,\n  ) => Promise<SendTransactionSyncReturnType>\n  /**\n   * Requests for the wallet to show information about a call batch\n   * that was sent via `sendCalls`.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/showCallsStatus\n   * - JSON-RPC Methods: [`wallet_showCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)\n   *\n   * @param client - Client to use\n   * @returns Displays status of the calls in wallet. {@link ShowCallsStatusReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   *\n   * await client.showCallsStatus({ id: '0xdeadbeef' })\n   */\n  showCallsStatus: (\n    parameters: ShowCallsStatusParameters,\n  ) => Promise<ShowCallsStatusReturnType>\n  /**\n   * Signs an [EIP-7702 Authorization](https://eips.ethereum.org/EIPS/eip-7702) object.\n   *\n   * With the calculated signature, you can:\n   * - use [`verifyAuthorization`](https://viem.sh/docs/eip7702/verifyAuthorization) to verify the signed Authorization object,\n   * - use [`recoverAuthorizationAddress`](https://viem.sh/docs/eip7702/recoverAuthorizationAddress) to recover the signing address from the signed Authorization object.\n   *\n   * @param client - Client to use\n   * @param parameters - {@link SignAuthorizationParameters}\n   * @returns The signed Authorization object. {@link SignAuthorizationReturnType}\n   *\n   * @example\n   * import { createWalletClient, http } from 'viem'\n   * import { privateKeyToAccount } from 'viem/accounts'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const signature = await client.signAuthorization({\n   *   account: privateKeyToAccount('0x..'),\n   *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   * })\n   *\n   * @example\n   * // Account Hoisting\n   * import { createWalletClient, http } from 'viem'\n   * import { privateKeyToAccount } from 'viem/accounts'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   account: privateKeyToAccount('0x…'),\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const signature = await client.signAuthorization({\n   *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   * })\n   */\n  signAuthorization: (\n    parameters: SignAuthorizationParameters<account>,\n  ) => Promise<SignAuthorizationReturnType>\n  /**\n   * Calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191): `keccak256(\"\\x19Ethereum Signed Message:\\n\" + len(message) + message))`.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/signMessage\n   * - JSON-RPC Methods:\n   *   - JSON-RPC Accounts: [`personal_sign`](https://docs.metamask.io/guide/signing-data#personal-sign)\n   *   - Local Accounts: Signs locally. No JSON-RPC request.\n   *\n   * With the calculated signature, you can:\n   * - use [`verifyMessage`](https://viem.sh/docs/utilities/verifyMessage) to verify the signature,\n   * - use [`recoverMessageAddress`](https://viem.sh/docs/utilities/recoverMessageAddress) to recover the signing address from a signature.\n   *\n   * @param args - {@link SignMessageParameters}\n   * @returns The signed message. {@link SignMessageReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const signature = await client.signMessage({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   message: 'hello world',\n   * })\n   *\n   * @example\n   * // Account Hoisting\n   * import { createWalletClient, http } from 'viem'\n   * import { privateKeyToAccount } from 'viem/accounts'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   account: privateKeyToAccount('0x…'),\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const signature = await client.signMessage({\n   *   message: 'hello world',\n   * })\n   */\n  signMessage: (\n    args: SignMessageParameters<account>,\n  ) => Promise<SignMessageReturnType>\n  /**\n   * Signs a transaction.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/signTransaction\n   * - JSON-RPC Methods:\n   *   - JSON-RPC Accounts: [`eth_signTransaction`](https://ethereum.github.io/execution-apis/api-documentation/)\n   *   - Local Accounts: Signs locally. No JSON-RPC request.\n   *\n   * @param args - {@link SignTransactionParameters}\n   * @returns The signed message. {@link SignTransactionReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const request = await client.prepareTransactionRequest({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   to: '0x0000000000000000000000000000000000000000',\n   *   value: 1n,\n   * })\n   * const signature = await client.signTransaction(request)\n   *\n   * @example\n   * // Account Hoisting\n   * import { createWalletClient, http } from 'viem'\n   * import { privateKeyToAccount } from 'viem/accounts'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   account: privateKeyToAccount('0x…'),\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const request = await client.prepareTransactionRequest({\n   *   to: '0x0000000000000000000000000000000000000000',\n   *   value: 1n,\n   * })\n   * const signature = await client.signTransaction(request)\n   */\n  signTransaction: <\n    chainOverride extends Chain | undefined,\n    const request extends SignTransactionRequest<\n      chain,\n      chainOverride\n    > = SignTransactionRequest<chain, chainOverride>,\n  >(\n    args: SignTransactionParameters<chain, account, chainOverride, request>,\n  ) => Promise<SignTransactionReturnType<request>>\n  /**\n   * Signs typed data and calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191): `keccak256(\"\\x19Ethereum Signed Message:\\n\" + len(message) + message))`.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/signTypedData\n   * - JSON-RPC Methods:\n   *   - JSON-RPC Accounts: [`eth_signTypedData_v4`](https://docs.metamask.io/guide/signing-data#signtypeddata-v4)\n   *   - Local Accounts: Signs locally. No JSON-RPC request.\n   *\n   * @param client - Client to use\n   * @param args - {@link SignTypedDataParameters}\n   * @returns The signed data. {@link SignTypedDataReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const signature = await client.signTypedData({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   domain: {\n   *     name: 'Ether Mail',\n   *     version: '1',\n   *     chainId: 1,\n   *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n   *   },\n   *   types: {\n   *     Person: [\n   *       { name: 'name', type: 'string' },\n   *       { name: 'wallet', type: 'address' },\n   *     ],\n   *     Mail: [\n   *       { name: 'from', type: 'Person' },\n   *       { name: 'to', type: 'Person' },\n   *       { name: 'contents', type: 'string' },\n   *     ],\n   *   },\n   *   primaryType: 'Mail',\n   *   message: {\n   *     from: {\n   *       name: 'Cow',\n   *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n   *     },\n   *     to: {\n   *       name: 'Bob',\n   *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n   *     },\n   *     contents: 'Hello, Bob!',\n   *   },\n   * })\n   *\n   * @example\n   * // Account Hoisting\n   * import { createWalletClient, http } from 'viem'\n   * import { privateKeyToAccount } from 'viem/accounts'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   account: privateKeyToAccount('0x…'),\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const signature = await client.signTypedData({\n   *   domain: {\n   *     name: 'Ether Mail',\n   *     version: '1',\n   *     chainId: 1,\n   *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n   *   },\n   *   types: {\n   *     Person: [\n   *       { name: 'name', type: 'string' },\n   *       { name: 'wallet', type: 'address' },\n   *     ],\n   *     Mail: [\n   *       { name: 'from', type: 'Person' },\n   *       { name: 'to', type: 'Person' },\n   *       { name: 'contents', type: 'string' },\n   *     ],\n   *   },\n   *   primaryType: 'Mail',\n   *   message: {\n   *     from: {\n   *       name: 'Cow',\n   *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n   *     },\n   *     to: {\n   *       name: 'Bob',\n   *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n   *     },\n   *     contents: 'Hello, Bob!',\n   *   },\n   * })\n   */\n  signTypedData: <\n    const typedData extends TypedData | { [key: string]: unknown },\n    primaryType extends string,\n  >(\n    args: SignTypedDataParameters<typedData, primaryType, account>,\n  ) => Promise<SignTypedDataReturnType>\n  /**\n   * Switch the target chain in a wallet.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/switchChain\n   * - JSON-RPC Methods: [`eth_switchEthereumChain`](https://eips.ethereum.org/EIPS/eip-3326)\n   *\n   * @param args - {@link SwitchChainParameters}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet, optimism } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * await client.switchChain({ id: optimism.id })\n   */\n  switchChain: (args: SwitchChainParameters) => Promise<void>\n  /**\n   * Waits for the status & receipts of a call bundle that was sent via `sendCalls`.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/waitForCallsStatus\n   * - JSON-RPC Methods: [`wallet_getCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)\n   *\n   * @param client - Client to use\n   * @param parameters - {@link WaitForCallsStatusParameters}\n   * @returns Status & receipts of the call bundle. {@link WaitForCallsStatusReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   *\n   * const { receipts, status } = await waitForCallsStatus(client, { id: '0xdeadbeef' })\n   */\n  waitForCallsStatus: (\n    parameters: WaitForCallsStatusParameters,\n  ) => Promise<WaitForCallsStatusReturnType>\n  /**\n   * Adds an EVM chain to the wallet.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/watchAsset\n   * - JSON-RPC Methods: [`eth_switchEthereumChain`](https://eips.ethereum.org/EIPS/eip-747)\n   *\n   * @param args - {@link WatchAssetParameters}\n   * @returns Boolean indicating if the token was successfully added. {@link WatchAssetReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const success = await client.watchAsset({\n   *   type: 'ERC20',\n   *   options: {\n   *     address: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',\n   *     decimals: 18,\n   *     symbol: 'WETH',\n   *   },\n   * })\n   */\n  watchAsset: (args: WatchAssetParameters) => Promise<WatchAssetReturnType>\n  /**\n   * Executes a write function on a contract.\n   *\n   * - Docs: https://viem.sh/docs/contract/writeContract\n   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_writing-to-contracts\n   *\n   * A \"write\" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, and hence a [Transaction](https://viem.sh/docs/glossary/terms) is needed to be broadcast in order to change the state.\n   *\n   * Internally, uses a [Wallet Client](https://viem.sh/docs/clients/wallet) to call the [`sendTransaction` action](https://viem.sh/docs/actions/wallet/sendTransaction) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n   *\n   * __Warning: The `write` internally sends a transaction – it does not validate if the contract write will succeed (the contract may throw an error). It is highly recommended to [simulate the contract write with `contract.simulate`](https://viem.sh/docs/contract/writeContract#usage) before you execute it.__\n   *\n   * @param args - {@link WriteContractParameters}\n   * @returns A [Transaction Hash](https://viem.sh/docs/glossary/terms#hash). {@link WriteContractReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom, parseAbi } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const hash = await client.writeContract({\n   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n   *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n   *   functionName: 'mint',\n   *   args: [69420],\n   * })\n   *\n   * @example\n   * // With Validation\n   * import { createWalletClient, custom, parseAbi } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const { request } = await client.simulateContract({\n   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n   *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n   *   functionName: 'mint',\n   *   args: [69420],\n   * }\n   * const hash = await client.writeContract(request)\n   */\n  writeContract: <\n    const abi extends Abi | readonly unknown[],\n    functionName extends ContractFunctionName<abi, 'payable' | 'nonpayable'>,\n    args extends ContractFunctionArgs<\n      abi,\n      'payable' | 'nonpayable',\n      functionName\n    >,\n    chainOverride extends Chain | undefined = undefined,\n  >(\n    args: WriteContractParameters<\n      abi,\n      functionName,\n      args,\n      chain,\n      account,\n      chainOverride\n    >,\n  ) => Promise<WriteContractReturnType>\n  /**\n   * Executes a write function on a contract synchronously.\n   * Returns the transaction receipt.\n   *\n   * - Docs: https://viem.sh/docs/contract/writeContract\n   *\n   * A \"write\" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, and hence a [Transaction](https://viem.sh/docs/glossary/terms) is needed to be broadcast in order to change the state.\n   *\n   * Internally, uses a [Wallet Client](https://viem.sh/docs/clients/wallet) to call the [`sendTransaction` action](https://viem.sh/docs/actions/wallet/sendTransaction) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n   *\n   * __Warning: The `write` internally sends a transaction – it does not validate if the contract write will succeed (the contract may throw an error). It is highly recommended to [simulate the contract write with `contract.simulate`](https://viem.sh/docs/contract/writeContract#usage) before you execute it.__\n   *\n   * @param args - {@link WriteContractSyncParameters}\n   * @returns A [Transaction Receipt](https://viem.sh/docs/glossary/terms#receipt). {@link WriteContractSyncReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom, parseAbi } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const receipt = await client.writeContractSync({\n   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n   *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n   *   functionName: 'mint',\n   *   args: [69420],\n   * })\n   */\n  writeContractSync: <\n    const abi extends Abi | readonly unknown[],\n    functionName extends ContractFunctionName<abi, 'payable' | 'nonpayable'>,\n    args extends ContractFunctionArgs<\n      abi,\n      'payable' | 'nonpayable',\n      functionName\n    >,\n    chainOverride extends Chain | undefined = undefined,\n  >(\n    args: WriteContractSyncParameters<\n      abi,\n      functionName,\n      args,\n      chain,\n      account,\n      chainOverride\n    >,\n  ) => Promise<WriteContractSyncReturnType>\n}\n\nexport function walletActions<\n  transport extends Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n>(client: Client<transport, chain, account>): WalletActions<chain, account> {\n  return {\n    addChain: (args) => addChain(client, args),\n    deployContract: (args) => deployContract(client, args),\n    getAddresses: () => getAddresses(client),\n    getCallsStatus: (args) => getCallsStatus(client, args),\n    getCapabilities: (args) => getCapabilities(client, args),\n    getChainId: () => getChainId(client),\n    getPermissions: () => getPermissions(client),\n    prepareAuthorization: (args) => prepareAuthorization(client, args),\n    prepareTransactionRequest: (args) =>\n      prepareTransactionRequest(client as any, args as any) as any,\n    requestAddresses: () => requestAddresses(client),\n    requestPermissions: (args) => requestPermissions(client, args),\n    sendCalls: (args) => sendCalls(client, args),\n    sendCallsSync: (args) => sendCallsSync(client, args),\n    sendRawTransaction: (args) => sendRawTransaction(client, args),\n    sendRawTransactionSync: (args) => sendRawTransactionSync(client, args),\n    sendTransaction: (args) => sendTransaction(client, args),\n    sendTransactionSync: (args) => sendTransactionSync(client, args),\n    showCallsStatus: (args) => showCallsStatus(client, args),\n    signAuthorization: (args) => signAuthorization(client, args),\n    signMessage: (args) => signMessage(client, args),\n    signTransaction: (args) => signTransaction(client, args),\n    signTypedData: (args) => signTypedData(client, args),\n    switchChain: (args) => switchChain(client, args),\n    waitForCallsStatus: (args) => waitForCallsStatus(client, args),\n    watchAsset: (args) => watchAsset(client, args),\n    writeContract: (args) => writeContract(client, args as any),\n    writeContractSync: (args) => writeContractSync(client, args as any),\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1919, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/@wagmi/core/dist/esm/actions/getWalletClient.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/%40wagmi/core/src/actions/getWalletClient.ts"],"sourcesContent":["import { type Account, type WalletClient, walletActions } from 'viem'\n\nimport type { Config } from '../createConfig.js'\nimport type { BaseErrorType, ErrorType } from '../errors/base.js'\nimport type { Compute } from '../types/utils.js'\nimport {\n  type GetConnectorClientErrorType,\n  type GetConnectorClientParameters,\n  getConnectorClient,\n} from './getConnectorClient.js'\n\nexport type GetWalletClientParameters<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n> = GetConnectorClientParameters<Config, chainId>\n\nexport type GetWalletClientReturnType<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n> = Compute<\n  WalletClient<\n    config['_internal']['transports'][chainId],\n    Extract<config['chains'][number], { id: chainId }>,\n    Account\n  >\n>\n\nexport type GetWalletClientErrorType =\n  // getConnectorClient()\n  | GetConnectorClientErrorType\n  // base\n  | BaseErrorType\n  | ErrorType\n\nexport async function getWalletClient<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n>(\n  config: config,\n  parameters: GetWalletClientParameters<config, chainId> = {},\n): Promise<GetWalletClientReturnType<config, chainId>> {\n  const client = await getConnectorClient(config, parameters)\n  // @ts-ignore\n  return client.extend(walletActions) as unknown as GetWalletClientReturnType<\n    config,\n    chainId\n  >\n}\n"],"names":[],"mappings":";;;;AAAA,OAAO,EAAmC,aAAa,EAAE,MAAM,MAAM,CAAA;AAKrE,OAAO,EAGL,kBAAkB,GACnB,MAAM,yBAAyB,CAAA;;;AA2BzB,KAAK,UAAU,eAAe,CAInC,MAAc,EACd,aAAyD,CAAA,CAAE;IAE3D,MAAM,MAAM,GAAG,UAAM,+PAAkB,EAAC,MAAM,EAAE,UAAU,CAAC,CAAA;IAC3D,aAAa;IACb,OAAO,MAAM,CAAC,MAAM,CAAC,0OAAa,CAGjC,CAAA;AACH,CAAC"}},
    {"offset": {"line": 1936, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/@wagmi/core/dist/esm/query/getWalletClient.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/%40wagmi/core/src/query/getWalletClient.ts"],"sourcesContent":["import type { QueryOptions } from '@tanstack/query-core'\n\nimport {\n  type GetWalletClientErrorType,\n  type GetWalletClientParameters,\n  type GetWalletClientReturnType,\n  getWalletClient,\n} from '../actions/getWalletClient.js'\nimport type { Config } from '../createConfig.js'\nimport type { ScopeKeyParameter } from '../types/properties.js'\nimport type { Compute, ExactPartial } from '../types/utils.js'\nimport { filterQueryOptions } from './utils.js'\n\nexport type GetWalletClientOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = Compute<\n  ExactPartial<GetWalletClientParameters<config, chainId>> & ScopeKeyParameter\n>\n\nexport function getWalletClientQueryOptions<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n>(config: config, options: GetWalletClientOptions<config, chainId> = {}) {\n  return {\n    gcTime: 0,\n    async queryFn({ queryKey }) {\n      const { connector } = options\n      const { connectorUid: _, scopeKey: _s, ...parameters } = queryKey[1]\n      return getWalletClient(config, { ...parameters, connector }) as never\n    },\n    queryKey: getWalletClientQueryKey(options),\n  } as const satisfies QueryOptions<\n    GetWalletClientQueryFnData<config, chainId>,\n    GetWalletClientErrorType,\n    GetWalletClientData<config, chainId>,\n    GetWalletClientQueryKey<config, chainId>\n  >\n}\n\nexport type GetWalletClientQueryFnData<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = GetWalletClientReturnType<config, chainId>\n\nexport type GetWalletClientData<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = GetWalletClientQueryFnData<config, chainId>\n\nexport function getWalletClientQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n>(options: GetWalletClientOptions<config, chainId> = {}) {\n  const { connector, ...parameters } = options\n  return [\n    'walletClient',\n    { ...filterQueryOptions(parameters), connectorUid: connector?.uid },\n  ] as const\n}\n\nexport type GetWalletClientQueryKey<\n  config extends Config,\n  chainId extends config['chains'][number]['id'],\n> = ReturnType<typeof getWalletClientQueryKey<config, chainId>>\n"],"names":[],"mappings":";;;;;;AAEA,OAAO,EAIL,eAAe,GAChB,MAAM,+BAA+B,CAAA;AAItC,OAAO,EAAE,kBAAkB,EAAE,MAAM,YAAY,CAAA;;;AASzC,SAAU,2BAA2B,CAGzC,MAAc,EAAE,UAAmD,CAAA,CAAE;IACrE,OAAO;QACL,MAAM,EAAE,CAAC;QACT,KAAK,CAAC,OAAO,EAAC,EAAE,QAAQ,EAAE;YACxB,MAAM,EAAE,SAAS,EAAE,GAAG,OAAO,CAAA;YAC7B,MAAM,EAAE,YAAY,EAAE,CAAC,EAAE,QAAQ,EAAE,EAAE,EAAE,GAAG,UAAU,EAAE,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAA;YACpE,WAAO,yPAAe,EAAC,MAAM,EAAE;gBAAE,GAAG,UAAU;gBAAE,SAAS;YAAA,CAAE,CAAU,CAAA;QACvE,CAAC;QACD,QAAQ,EAAE,uBAAuB,CAAC,OAAO,CAAC;KAM3C,CAAA;AACH,CAAC;AAYK,SAAU,uBAAuB,CAGrC,UAAmD,CAAA,CAAE;IACrD,MAAM,EAAE,SAAS,EAAE,GAAG,UAAU,EAAE,GAAG,OAAO,CAAA;IAC5C,OAAO;QACL,cAAc;QACd;YAAE,OAAG,gPAAkB,EAAC,UAAU,CAAC;YAAE,YAAY,EAAE,SAAS,EAAE,GAAG;QAAA,CAAE;KAC3D,CAAA;AACZ,CAAC"}},
    {"offset": {"line": 1974, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/Desktop/Folder/BlockBelle/next-frontend/node_modules/wagmi/dist/esm/hooks/useWalletClient.js","sources":["file:///C:/Users/HP/Desktop/Folder/BlockBelle/next-frontend/node_modules/wagmi/src/hooks/useWalletClient.ts"],"sourcesContent":["'use client'\n\n// Almost identical implementation to `useConnectorClient` (except for return type)\n// Should update both in tandem\n\nimport { useQueryClient } from '@tanstack/react-query'\nimport type {\n  Config,\n  GetWalletClientErrorType,\n  ResolvedRegister,\n} from '@wagmi/core'\nimport type { Compute, Omit } from '@wagmi/core/internal'\nimport {\n  type GetWalletClientData,\n  type GetWalletClientOptions,\n  type GetWalletClientQueryFnData,\n  type GetWalletClientQueryKey,\n  getWalletClientQueryOptions,\n} from '@wagmi/core/query'\nimport { useEffect, useRef } from 'react'\n\nimport type { ConfigParameter } from '../types/properties.js'\nimport {\n  type UseQueryParameters,\n  type UseQueryReturnType,\n  useQuery,\n} from '../utils/query.js'\nimport { useAccount } from './useAccount.js'\nimport { useChainId } from './useChainId.js'\nimport { useConfig } from './useConfig.js'\n\nexport type UseWalletClientParameters<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetWalletClientData<config, chainId>,\n> = Compute<\n  GetWalletClientOptions<config, chainId> &\n    ConfigParameter<config> & {\n      query?:\n        | Compute<\n            Omit<\n              UseQueryParameters<\n                GetWalletClientQueryFnData<config, chainId>,\n                GetWalletClientErrorType,\n                selectData,\n                GetWalletClientQueryKey<config, chainId>\n              >,\n              'gcTime' | 'staleTime'\n            >\n          >\n        | undefined\n    }\n>\n\nexport type UseWalletClientReturnType<\n  config extends Config = Config,\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetWalletClientData<config, chainId>,\n> = UseQueryReturnType<selectData, GetWalletClientErrorType>\n\n/** https://wagmi.sh/react/api/hooks/useWalletClient */\nexport function useWalletClient<\n  config extends Config = ResolvedRegister['config'],\n  chainId extends\n    config['chains'][number]['id'] = config['chains'][number]['id'],\n  selectData = GetWalletClientData<config, chainId>,\n>(\n  parameters: UseWalletClientParameters<config, chainId, selectData> = {},\n): UseWalletClientReturnType<config, chainId, selectData> {\n  const { query = {}, ...rest } = parameters\n\n  const config = useConfig(rest)\n  const queryClient = useQueryClient()\n  const { address, connector, status } = useAccount({ config })\n  const chainId = useChainId({ config })\n  const activeConnector = parameters.connector ?? connector\n\n  const { queryKey, ...options } = getWalletClientQueryOptions<config, chainId>(\n    config,\n    {\n      ...parameters,\n      chainId: parameters.chainId ?? chainId,\n      connector: parameters.connector ?? connector,\n    },\n  )\n  const enabled = Boolean(\n    (status === 'connected' ||\n      (status === 'reconnecting' && activeConnector?.getProvider)) &&\n      (query.enabled ?? true),\n  )\n\n  const addressRef = useRef(address)\n  // biome-ignore lint/correctness/useExhaustiveDependencies: `queryKey` not required\n  useEffect(() => {\n    const previousAddress = addressRef.current\n    if (!address && previousAddress) {\n      // remove when account is disconnected\n      queryClient.removeQueries({ queryKey })\n      addressRef.current = undefined\n    } else if (address !== previousAddress) {\n      // invalidate when address changes\n      queryClient.invalidateQueries({ queryKey })\n      addressRef.current = address\n    }\n  }, [address, queryClient])\n\n  return useQuery({\n    ...query,\n    ...options,\n    queryKey,\n    enabled,\n    staleTime: Number.POSITIVE_INFINITY,\n  } as any) as UseWalletClientReturnType<config, chainId, selectData>\n}\n"],"names":[],"mappings":";;;;AAEA,mFAAmF;AACnF,+BAA+B;AAE/B,OAAO,EAAE,cAAc,EAAE,MAAM,uBAAuB,CAAA;AAOtD,OAAO,EAKL,2BAA2B,GAC5B,MAAM,mBAAmB,CAAA;AAC1B,OAAO,EAAE,SAAS,EAAE,MAAM,EAAE,MAAM,OAAO,CAAA;AAGzC,OAAO,EAGL,QAAQ,GACT,MAAM,mBAAmB,CAAA;AAC1B,OAAO,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAA;AAC5C,OAAO,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAA;AAC5C,OAAO,EAAE,SAAS,EAAE,MAAM,gBAAgB,CAAA;AA7B1C,YAAY,CAAA;;;;;;;;AA+DN,SAAU,eAAe,CAM7B,aAAqE,CAAA,CAAE;IAEvE,MAAM,EAAE,KAAK,GAAG,CAAA,CAAE,EAAE,GAAG,IAAI,EAAE,GAAG,UAAU,CAAA;IAE1C,MAAM,MAAM,OAAG,iOAAS,EAAC,IAAI,CAAC,CAAA;IAC9B,MAAM,WAAW,OAAG,kQAAc,EAAE,CAAA;IACpC,MAAM,EAAE,OAAO,EAAE,SAAS,EAAE,MAAM,EAAE,OAAG,mOAAU,EAAC;QAAE,MAAM;IAAA,CAAE,CAAC,CAAA;IAC7D,MAAM,OAAO,OAAG,mOAAU,EAAC;QAAE,MAAM;IAAA,CAAE,CAAC,CAAA;IACtC,MAAM,eAAe,GAAG,UAAU,CAAC,SAAS,IAAI,SAAS,CAAA;IAEzD,MAAM,EAAE,QAAQ,EAAE,GAAG,OAAO,EAAE,OAAG,mQAA2B,EAC1D,MAAM,EACN;QACE,GAAG,UAAU;QACb,OAAO,EAAE,UAAU,CAAC,OAAO,IAAI,OAAO;QACtC,SAAS,EAAE,UAAU,CAAC,SAAS,IAAI,SAAS;KAC7C,CACF,CAAA;IACD,MAAM,OAAO,GAAG,OAAO,CACrB,CAAC,MAAM,KAAK,WAAW,IACpB,MAAM,KAAK,cAAc,IAAI,eAAe,EAAE,WAAW,AAAC,CAAC,IAC5D,CAAC,KAAK,CAAC,OAAO,IAAI,IAAI,CAAC,CAC1B,CAAA;IAED,MAAM,UAAU,OAAG,8NAAM,EAAC,OAAO,CAAC,CAAA;IAClC,mFAAmF;QACnF,iOAAS;qCAAC,GAAG,EAAE;YACb,MAAM,eAAe,GAAG,UAAU,CAAC,OAAO,CAAA;YAC1C,IAAI,CAAC,OAAO,IAAI,eAAe,EAAE,CAAC;gBAChC,sCAAsC;gBACtC,WAAW,CAAC,aAAa,CAAC;oBAAE,QAAQ;gBAAA,CAAE,CAAC,CAAA;gBACvC,UAAU,CAAC,OAAO,GAAG,SAAS,CAAA;YAChC,CAAC,MAAM,IAAI,OAAO,KAAK,eAAe,EAAE,CAAC;gBACvC,kCAAkC;gBAClC,WAAW,CAAC,iBAAiB,CAAC;oBAAE,QAAQ;gBAAA,CAAE,CAAC,CAAA;gBAC3C,UAAU,CAAC,OAAO,GAAG,OAAO,CAAA;YAC9B,CAAC;QACH,CAAC;oCAAE;QAAC,OAAO;QAAE,WAAW;KAAC,CAAC,CAAA;IAE1B,WAAO,4OAAQ,EAAC;QACd,GAAG,KAAK;QACR,GAAG,OAAO;QACV,QAAQ;QACR,OAAO;QACP,SAAS,EAAE,MAAM,CAAC,iBAAiB;KAC7B,CAA2D,CAAA;AACrE,CAAC"}}]
}