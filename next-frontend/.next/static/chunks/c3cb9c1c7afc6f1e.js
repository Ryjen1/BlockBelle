(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["object"==typeof document?document.currentScript:void 0,200743,(e,t,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),Object.defineProperty(r,"warnOnce",{enumerable:!0,get:function(){return a}});let a=e=>{}},542837,(e,t,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),Object.defineProperty(r,"useMergedRef",{enumerable:!0,get:function(){return n}});let a=e.r(22752);function n(e,t){let r=(0,a.useRef)(null),n=(0,a.useRef)(null);return(0,a.useCallback)(a=>{if(null===a){let e=r.current;e&&(r.current=null,e());let t=n.current;t&&(n.current=null,t())}else e&&(r.current=o(e,a)),t&&(n.current=o(t,a))},[e,t])}function o(e,t){if("function"!=typeof e)return e.current=t,()=>{e.current=null};{let r=e(t);return"function"==typeof r?r:()=>e(null)}}("function"==typeof r.default||"object"==typeof r.default&&null!==r.default)&&void 0===r.default.__esModule&&(Object.defineProperty(r.default,"__esModule",{value:!0}),Object.assign(r.default,r),t.exports=r.default)},612431,e=>{"use strict";var t=e.i(533749);function r({chain:e,currentChainId:r}){if(!e)throw new t.ChainNotFoundError;if(r!==e.id)throw new t.ChainMismatchError({chain:e,currentChainId:r})}e.s(["assertCurrentChain",()=>r])},540310,e=>{"use strict";var t=e.i(365049),r=e.i(168213),a=e.i(897124);function n(e,{docsPath:n,...o}){let i,s=(i=(0,a.getNodeError)(e,o))instanceof t.UnknownNodeError?e:i;return new r.TransactionExecutionError(s,{docsPath:n,...o})}e.s(["getTransactionError",()=>n])},504454,e=>{"use strict";var t=e.i(814304),r=e.i(825934),a=e.i(706403),n=e.i(141670),o=e.i(612431),i=e.i(540310),s=e.i(436096),c=e.i(100726),u=e.i(339574),l=e.i(547289),d=e.i(355490),p=e.i(911632),f=e.i(34886),h=e.i(488979);let w=new l.LruMap(128);async function m(e,l){let{account:m=e.account,chain:g=e.chain,accessList:b,authorizationList:v,blobs:y,data:T,gas:C,gasPrice:E,maxFeePerBlobGas:x,maxFeePerGas:A,maxPriorityFeePerGas:R,nonce:N,type:I,value:P,...M}=l;if(void 0===m)throw new r.AccountNotFoundError({docsPath:"/docs/actions/wallet/sendTransaction"});let S=m?(0,t.parseAccount)(m):null;try{(0,d.assertRequest)(l);let t=await (async()=>l.to?l.to:null!==l.to&&v&&v.length>0?await (0,n.recoverAuthorizationAddress)({authorization:v[0]}).catch(()=>{throw new a.BaseError("`to` is required. Could not infer from `authorizationList`.")}):void 0)();if(S?.type==="json-rpc"||null===S){let r;null!==g&&(r=await (0,u.getAction)(e,p.getChainId,"getChainId")({}),(0,o.assertCurrentChain)({currentChainId:r,chain:g}));let a=e.chain?.formatters?.transactionRequest?.format,n=(a||c.formatTransactionRequest)({...(0,s.extract)(M,{format:a}),accessList:b,account:S,authorizationList:v,blobs:y,chainId:r,data:T,gas:C,gasPrice:E,maxFeePerBlobGas:x,maxFeePerGas:A,maxPriorityFeePerGas:R,nonce:N,to:t,type:I,value:P},"sendTransaction"),i=w.get(e.uid);try{return await e.request({method:i?"wallet_sendTransaction":"eth_sendTransaction",params:[n]},{retryCount:0})}catch(t){if(!1===i)throw t;if("InvalidInputRpcError"===t.name||"InvalidParamsRpcError"===t.name||"MethodNotFoundRpcError"===t.name||"MethodNotSupportedRpcError"===t.name)return await e.request({method:"wallet_sendTransaction",params:[n]},{retryCount:0}).then(t=>(w.set(e.uid,!0),t)).catch(r=>{if("MethodNotFoundRpcError"===r.name||"MethodNotSupportedRpcError"===r.name)throw w.set(e.uid,!1),t;throw r});throw t}}if(S?.type==="local"){let r=await (0,u.getAction)(e,f.prepareTransactionRequest,"prepareTransactionRequest")({account:S,accessList:b,authorizationList:v,blobs:y,chain:g,data:T,gas:C,gasPrice:E,maxFeePerBlobGas:x,maxFeePerGas:A,maxPriorityFeePerGas:R,nonce:N,nonceManager:S.nonceManager,parameters:[...f.defaultParameters,"sidecars"],type:I,value:P,...M,to:t}),a=g?.serializers?.transaction,n=await S.signTransaction(r,{serializer:a});return await (0,u.getAction)(e,h.sendRawTransaction,"sendRawTransaction")({serializedTransaction:n})}if(S?.type==="smart")throw new r.AccountTypeNotSupportedError({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"});throw new r.AccountTypeNotSupportedError({docsPath:"/docs/actions/wallet/sendTransaction",type:S?.type})}catch(e){if(e instanceof r.AccountTypeNotSupportedError)throw e;throw(0,i.getTransactionError)(e,{...l,account:S,chain:l.chain||void 0})}}e.s(["sendTransaction",()=>m])},339205,e=>{"use strict";var t=e.i(287030),r=e.i(118870);function a(e){let{key:a="public",name:n="Public Client"}=e;return(0,t.createClient)({...e,key:a,name:n,type:"publicClient"}).extend(r.publicActions)}e.s(["createPublicClient",()=>a])},425145,718855,e=>{"use strict";var t=e.i(312421),r=e.i(999385),a=e.i(902510),n=e.i(635804),o=e.i(814304),i=e.i(706403),s=e.i(475683),c=e.i(502134),u=e.i(38965),l=e.i(710793),d=e.i(540310),p=e.i(504454);let f="0x5792579257925792579257925792579257925792579257925792579257925792",h=(0,l.numberToHex)(0,{size:32});async function w(e,t){let{account:r=e.account,capabilities:n,chain:w=e.chain,experimental_fallback:m,experimental_fallbackDelay:g=32,forceAtomic:b=!1,id:v,version:y="2.0.0"}=t,T=r?(0,o.parseAccount)(r):null,C=t.calls.map(e=>{let t=e.abi?(0,c.encodeFunctionData)({abi:e.abi,functionName:e.functionName,args:e.args}):e.data;return{data:e.dataSuffix&&t?(0,u.concat)([t,e.dataSuffix]):t,to:e.to,value:e.value?(0,l.numberToHex)(e.value):void 0}});try{let t=await e.request({method:"wallet_sendCalls",params:[{atomicRequired:b,calls:C,capabilities:n,chainId:(0,l.numberToHex)(w.id),from:T?.address,id:v,version:y}]},{retryCount:0});if("string"==typeof t)return{id:t};return t}catch(r){if(m&&("MethodNotFoundRpcError"===r.name||"MethodNotSupportedRpcError"===r.name||"UnknownRpcError"===r.name||r.details.toLowerCase().includes("does not exist / is not available")||r.details.toLowerCase().includes("missing or invalid. request()")||r.details.toLowerCase().includes("did not match any variant of untagged enum")||r.details.toLowerCase().includes("account upgraded to unsupported contract")||r.details.toLowerCase().includes("eip-7702 not supported")||r.details.toLowerCase().includes("unsupported wc_ method")||r.details.toLowerCase().includes("feature toggled misconfigured")||r.details.toLowerCase().includes("jsonrpcengine: response has no error or result for request"))){if(n&&Object.values(n).some(e=>!e.optional)){let e="non-optional `capabilities` are not supported on fallback to `eth_sendTransaction`.";throw new s.UnsupportedNonOptionalCapabilityError(new i.BaseError(e,{details:e}))}if(b&&C.length>1){let e="`forceAtomic` is not supported on fallback to `eth_sendTransaction`.";throw new s.AtomicityNotSupportedError(new i.BaseError(e,{details:e}))}let t=[];for(let r of C){let n=(0,p.sendTransaction)(e,{account:T,chain:w,data:r.data,to:r.to,value:r.value?(0,a.hexToBigInt)(r.value):void 0});t.push(n),g>0&&await new Promise(e=>setTimeout(e,g))}let r=await Promise.allSettled(t);if(r.every(e=>"rejected"===e.status))throw r[0].reason;let o=r.map(e=>"fulfilled"===e.status?e.value:h);return{id:(0,u.concat)([...o,(0,l.numberToHex)(w.id,{size:32}),f])}}throw(0,d.getTransactionError)(r,{...t,account:T,chain:t.chain})}}async function m(e,o){let i;async function s(n){if(n.endsWith(f.slice(2))){let o=(0,r.trim)((0,t.sliceHex)(n,-64,-32)),i=(0,t.sliceHex)(n,0,-64).slice(2).match(/.{1,64}/g),s=await Promise.all(i.map(t=>h.slice(2)!==t?e.request({method:"eth_getTransactionReceipt",params:[`0x${t}`]},{dedupe:!0}):void 0)),c=s.some(e=>null===e)?100:s.every(e=>e?.status==="0x1")?200:s.every(e=>e?.status==="0x0")?500:600;return{atomic:!1,chainId:(0,a.hexToNumber)(o),receipts:s.filter(Boolean),status:c,version:"2.0.0"}}return e.request({method:"wallet_getCallsStatus",params:[n]})}let{atomic:c=!1,chainId:u,receipts:l,version:d="2.0.0",...p}=await s(o.id),[w,m]=(i=p.status)>=100&&i<200?["pending",i]:i>=200&&i<300?["success",i]:i>=300&&i<700?["failure",i]:"CONFIRMED"===i?["success",200]:"PENDING"===i?["pending",100]:[void 0,i];return{...p,atomic:c,chainId:u?(0,a.hexToNumber)(u):void 0,receipts:l?.map(e=>({...e,blockNumber:(0,a.hexToBigInt)(e.blockNumber),gasUsed:(0,a.hexToBigInt)(e.gasUsed),status:n.receiptStatuses[e.status]}))??[],statusCode:m,status:w,version:d}}e.s(["fallbackMagicIdentifier",0,f,"fallbackTransactionErrorMagicIdentifier",0,h,"sendCalls",()=>w],718855),e.s(["getCallsStatus",()=>m],425145)},807717,795338,e=>{"use strict";var t=e.i(814304),r=e.i(825934),a=e.i(503894),n=e.i(339574),o=e.i(911632),i=e.i(850186);async function s(e,s){let{account:c=e.account,chainId:u,nonce:l}=s;if(!c)throw new r.AccountNotFoundError({docsPath:"/docs/eip7702/prepareAuthorization"});let d=(0,t.parseAccount)(c),p=(()=>{if(s.executor)return"self"===s.executor?s.executor:(0,t.parseAccount)(s.executor)})(),f={address:s.contractAddress??s.address,chainId:u,nonce:l};return void 0===f.chainId&&(f.chainId=e.chain?.id??await (0,n.getAction)(e,o.getChainId,"getChainId")({})),void 0===f.nonce&&(f.nonce=await (0,n.getAction)(e,i.getTransactionCount,"getTransactionCount")({address:d.address,blockTag:"pending"}),("self"===p||p?.address&&(0,a.isAddressEqual)(p.address,d.address))&&(f.nonce+=1)),f}e.s(["prepareAuthorization",()=>s],807717);var c=e.i(706403);class u extends c.BaseError{constructor(e){super(`Call bundle failed with status: ${e.statusCode}`,{name:"BundleFailedError"}),Object.defineProperty(this,"result",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.result=e}}e.s(["BundleFailedError",()=>u],795338)},916679,e=>{"use strict";var t=e.i(706403),r=e.i(795338),a=e.i(339574),n=e.i(661522),o=e.i(650304),i=e.i(631003),s=e.i(776395),c=e.i(377472),u=e.i(425145);async function l(e,t){let l,{id:p,pollingInterval:f=e.pollingInterval,status:h=({statusCode:e})=>200===e||e>=300,retryCount:w=4,retryDelay:m=({count:e})=>200*~~(1<<e),timeout:g=6e4,throwOnFailure:b=!1}=t,v=(0,c.stringify)(["waitForCallsStatus",e.uid,p]),{promise:y,resolve:T,reject:C}=(0,i.withResolvers)(),E=(0,n.observe)(v,{resolve:T,reject:C},t=>{let n=(0,o.poll)(async()=>{let o=e=>{clearTimeout(l),n(),e(),E()};try{let n=await (0,s.withRetry)(async()=>{let t=await (0,a.getAction)(e,u.getCallsStatus,"getCallsStatus")({id:p});if(b&&"failure"===t.status)throw new r.BundleFailedError(t);return t},{retryCount:w,delay:m});if(!h(n))return;o(()=>t.resolve(n))}catch(e){o(()=>t.reject(e))}},{interval:f,emitOnBegin:!0});return n});return l=g?setTimeout(()=>{E(),clearTimeout(l),C(new d({id:p}))},g):void 0,await y}class d extends t.BaseError{constructor({id:e}){super(`Timed out while waiting for call bundle with id "${e}" to be confirmed.`,{name:"WaitForCallsStatusTimeoutError"})}}e.s(["waitForCallsStatus",()=>l])}]);